defmodule Mix.Tasks.Venues.CleanGwdNames do
  @moduledoc """
  Cleans Geeks Who Drink venue names by removing extraneous text.

  Fixes venue names like:
  - "Wild Corgi Pub (check venue for reservations!)" â†’ "Wild Corgi Pub"
  - "Pandora's Box @Alamo Drafthouse Westminster (Monday)" â†’ "Pandora's Box"

  Usage:
      mix venues.clean_gwd_names
      mix venues.clean_gwd_names --dry-run
  """

  use Mix.Task
  require Logger
  import Ecto.Query
  alias EventasaurusApp.Repo
  alias EventasaurusApp.Venues.Venue
  alias EventasaurusDiscovery.Sources.GeeksWhoDrink.Transformer

  @shortdoc "Clean Geeks Who Drink venue names"

  def run(args) do
    Mix.Task.run("app.start")

    dry_run = "--dry-run" in args

    Logger.info("""
    ğŸ§¹ Cleaning Geeks Who Drink venue names...
    Mode: #{if dry_run, do: "DRY RUN", else: "LIVE"}
    """)

    # Find all venues with dirty names (@ or parentheses)
    venues =
      from(v in Venue,
        where: fragment("? ~ ? OR ? ~ ?", v.name, "@", v.name, "\\([^)]+\\)")
      )
      |> Repo.all()

    Logger.info("Found #{length(venues)} venues with dirty names\n")

    results =
      Enum.map(venues, fn venue ->
        clean_name = Transformer.clean_venue_name(venue.name)
        needs_cleaning = clean_name != venue.name

        if needs_cleaning do
          Logger.info("""
          Venue ##{venue.id}:
            Old name: #{venue.name}
            New name: #{clean_name}
            Old slug: #{venue.slug}
          """)

          if dry_run do
            {:dry_run, venue, clean_name}
          else
            case update_venue_name(venue, clean_name) do
              {:ok, updated_venue} ->
                Logger.info("  âœ… Updated slug: #{updated_venue.slug}\n")
                {:updated, venue, updated_venue}

              {:error, changeset} ->
                Logger.error("  âŒ Failed to update: #{inspect(changeset.errors)}\n")
                {:error, venue, changeset}
            end
          end
        else
          {:skip, venue}
        end
      end)

    # Print summary
    updated = Enum.count(results, &match?({:updated, _, _}, &1))
    dry_run_count = Enum.count(results, &match?({:dry_run, _, _}, &1))
    skipped = Enum.count(results, &match?({:skip, _}, &1))
    errors = Enum.count(results, &match?({:error, _, _}, &1))

    Logger.info("""

    ğŸ“Š Summary:
    - Total venues checked: #{length(venues)}
    - #{if dry_run, do: "Would update", else: "Updated"}: #{if dry_run, do: dry_run_count, else: updated}
    - Skipped (already clean): #{skipped}
    - Errors: #{errors}
    """)

    if dry_run do
      Logger.info("\nğŸ’¡ Run without --dry-run to apply changes")
    end

    :ok
  end

  defp update_venue_name(venue, new_name) do
    # Create changeset with new name
    # The slug will be automatically regenerated by the Venue.Slug module
    changeset =
      venue
      |> Ecto.Changeset.change(name: new_name)
      # Force slug regeneration
      |> Ecto.Changeset.force_change(:slug, nil)

    case Repo.update(changeset) do
      {:ok, updated_venue} ->
        # Manually trigger slug generation if nil
        if is_nil(updated_venue.slug) do
          updated_venue
          |> Ecto.Changeset.change(%{})
          |> Venue.Slug.maybe_generate_slug()
          |> Repo.update()
        else
          {:ok, updated_venue}
        end

      error ->
        error
    end
  end
end
