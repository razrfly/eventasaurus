defmodule EventasaurusApp.Accounts do
  @moduledoc """
  The Accounts context.
  """

  import Ecto.Query, warn: false
  alias EventasaurusApp.Repo
  alias EventasaurusApp.Accounts.User
  alias EventasaurusApp.Accounts.UserPreferences
  alias EventasaurusApp.Families

  @doc """
  Returns the list of users.
  """
  def list_users do
    Repo.all(User)
  end

  @doc """
  Gets a single user.

  Raises `Ecto.NoResultsError` if the User does not exist.
  """
  def get_user!(id), do: Repo.get!(User, id)

  @doc """
  Gets a single user.

  Returns nil if the User does not exist.
  """
  def get_user(id), do: Repo.get(User, id)

  @doc """
  Gets multiple users by their IDs in a single query.

  Returns a list of users found. IDs with no matching user are silently skipped.
  """
  @spec get_users_by_ids([integer() | String.t()]) :: [User.t()]
  def get_users_by_ids([]), do: []

  def get_users_by_ids(ids) when is_list(ids) do
    from(u in User, where: u.id in ^ids)
    |> Repo.all()
  end

  @doc """
  Gets a user by email (case-insensitive).
  Returns nil if email is invalid or user not found.
  """
  def get_user_by_email(email) when is_binary(email) do
    case EventasaurusApp.Sanitizer.sanitize_email(email) do
      {:error, _reason} ->
        # Invalid email format, return nil
        nil

      nil ->
        nil

      normalized_email when is_binary(normalized_email) ->
        Repo.get_by(User, email: normalized_email)
    end
  end

  def get_user_by_email(_), do: nil

  @doc """
  Gets a user by username (case-insensitive).
  """
  def get_user_by_username(username) when is_binary(username) do
    from(u in User, where: fragment("lower(?)", u.username) == ^String.downcase(username))
    |> Repo.one()
  end

  @doc """
  Gets a user by username or ID.
  First tries to find by username, then falls back to ID lookup.
  Also handles "user-{id}" patterns generated by User.username_slug/1 for users without usernames.
  """
  def get_user_by_username_or_id(identifier) when is_binary(identifier) do
    # First try username lookup
    case get_user_by_username(identifier) do
      %User{} = user ->
        user

      nil ->
        # Check if it's a "user-{id}" pattern from username_slug
        case Regex.run(~r/^user-(\d+)$/, identifier) do
          [_, id_str] ->
            case Integer.parse(id_str) do
              {id, ""} -> get_user(id)
              _ -> nil
            end

          nil ->
            # Try regular ID lookup if not a "user-{id}" pattern
            case Integer.parse(identifier) do
              {id, ""} -> get_user(id)
              _ -> nil
            end
        end
    end
  end

  @doc """
  Creates a user.

  If no username is provided, one is automatically generated based on the user's
  name or email. If a collision occurs on the generated username, the system
  retries with an alternative unique username.
  """
  @spec create_user(map()) :: {:ok, User.t()} | {:error, Ecto.Changeset.t()}
  def create_user(attrs \\ %{}) do
    attrs =
      attrs
      |> maybe_generate_username()
      |> maybe_assign_family_name()

    case do_create_user(attrs) do
      {:ok, user} ->
        {:ok, user}

      {:error, %Ecto.Changeset{} = changeset} ->
        if username_conflict?(changeset) do
          # Retry with a timestamp-based unique username
          retry_with_unique_username(attrs)
        else
          {:error, changeset}
        end
    end
  end

  # Generate a username if one wasn't provided
  defp maybe_generate_username(attrs) do
    # Check for both atom and string keys
    has_username =
      Map.has_key?(attrs, :username) ||
        Map.has_key?(attrs, "username")

    if has_username do
      attrs
    else
      # Generate base username from attrs (name or email based)
      username = User.generate_username(attrs)
      Map.put(attrs, :username, username)
    end
  end

  # Assign a random family name if one wasn't provided (or was nil/empty)
  defp maybe_assign_family_name(attrs) do
    family_name =
      Map.get(attrs, :family_name) ||
        Map.get(attrs, "family_name")

    if is_binary(family_name) and family_name != "" do
      attrs
    else
      Map.put(attrs, :family_name, Families.random_family_name())
    end
  end

  defp do_create_user(attrs) do
    %User{}
    |> User.changeset(attrs)
    |> Repo.insert()
  end

  # Check if the changeset error is specifically a username uniqueness conflict
  defp username_conflict?(changeset) do
    Enum.any?(changeset.errors, fn
      {:username, {_, opts}} when is_list(opts) ->
        Keyword.get(opts, :constraint) == :unique

      _ ->
        false
    end)
  end

  # Retry user creation with a guaranteed-unique timestamp-based username
  defp retry_with_unique_username(attrs) do
    # Use microsecond timestamp for uniqueness
    unique_username = "user-#{System.system_time(:microsecond)}"
    attrs = Map.put(attrs, :username, unique_username)
    do_create_user(attrs)
  end

  @doc """
  Updates a user.
  """
  def update_user(%User{} = user, attrs) do
    user
    |> User.changeset(attrs)
    |> Repo.update()
  end

  @doc """
  Deletes a user.
  """
  def delete_user(%User{} = user) do
    Repo.delete(user)
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking user changes.
  """
  def change_user(%User{} = user, attrs \\ %{}) do
    User.changeset(user, attrs)
  end

  @doc """
  Finds or creates a user by email for guest invitations.
  If the user doesn't exist, creates a minimal user record with the email.
  Returns {:ok, user} or {:error, reason}.
  """
  def find_or_create_guest_user(email) when is_binary(email) do
    # Normalize and validate the email first
    case EventasaurusApp.Sanitizer.sanitize_email(email) do
      {:error, reason} ->
        # Invalid email format
        {:error, {:invalid_email, reason}}

      nil ->
        {:error, {:invalid_email, "Email cannot be nil"}}

      normalized_email when is_binary(normalized_email) ->
        case get_user_by_email(normalized_email) do
          %User{} = user ->
            {:ok, user}

          nil ->
            name = extract_name_from_email(normalized_email)

            user_params = %{
              email: normalized_email,
              name: name
            }

            create_user(user_params)
        end
    end
  end

  def find_or_create_guest_user(_), do: {:error, {:invalid_email, "Email must be a string"}}

  @doc """
  Search for users by name, username, or email.

  Options:
  - exclude_ids: List of user IDs to exclude from results
  - limit: Maximum number of results to return (default: 10)
  """
  def search_users(query, opts \\ []) when is_binary(query) do
    exclude_ids = Keyword.get(opts, :exclude_ids, [])
    limit = Keyword.get(opts, :limit, 10)

    search_query = String.trim(query)

    if search_query == "" do
      {:ok, []}
    else
      # Create search pattern for ILIKE
      search_pattern = "%#{search_query}%"

      users =
        from(u in User,
          where:
            (ilike(u.name, ^search_pattern) or
               ilike(u.username, ^search_pattern) or
               ilike(u.email, ^search_pattern)) and
              (^(exclude_ids == []) or u.id not in ^exclude_ids),
          limit: ^limit,
          order_by: [
            # Prioritize exact matches
            fragment("CASE
              WHEN lower(?) = lower(?) THEN 0
              WHEN lower(?) = lower(?) THEN 0
              WHEN lower(?) = lower(?) THEN 0
              ELSE 1
            END", u.name, ^search_query, u.username, ^search_query, u.email, ^search_query),
            # Then prioritize starts-with matches
            fragment(
              "CASE
              WHEN lower(?) LIKE lower(?) THEN 0
              WHEN lower(?) LIKE lower(?) THEN 0
              WHEN lower(?) LIKE lower(?) THEN 0
              ELSE 1
            END",
              u.name,
              ^"#{search_query}%",
              u.username,
              ^"#{search_query}%",
              u.email,
              ^"#{search_query}%"
            ),
            # Finally order by name
            u.name
          ]
        )
        |> Repo.all()

      {:ok, users}
    end
  rescue
    _ -> {:error, :search_failed}
  end

  @doc """
  Gets user event statistics for profile display.

  Returns a map with:
  - hosted: Number of events the user has organized/hosted
  - attended: Number of events the user has attended
  - together: Number of unique other users they've shared events with
  """
  def get_user_event_stats(%User{} = user) do
    alias EventasaurusApp.Events.{Event, EventUser, EventParticipant}
    import Ecto.Query

    # Count hosted events (user is in event_users table)
    hosted_count =
      from(eu in EventUser,
        join: e in Event,
        on: eu.event_id == e.id,
        where: eu.user_id == ^user.id and is_nil(e.deleted_at) and is_nil(eu.deleted_at),
        select: count(e.id)
      )
      |> Repo.one(with_deleted: true)

    # Count attended events (user is in event_participants table)
    attended_count =
      from(ep in EventParticipant,
        join: e in Event,
        on: ep.event_id == e.id,
        where: ep.user_id == ^user.id and is_nil(e.deleted_at) and is_nil(ep.deleted_at),
        select: count(e.id, :distinct)
      )
      |> Repo.one(with_deleted: true)

    # Count unique other users they've shared events with (both as organizer and participant)
    # First query: Events where user was organizer - get other participants
    organizer_participants_query =
      from(eu in EventUser,
        join: e in Event,
        on: eu.event_id == e.id,
        join: ep in EventParticipant,
        on: e.id == ep.event_id,
        where:
          eu.user_id == ^user.id and ep.user_id != ^user.id and
            is_nil(e.deleted_at) and is_nil(eu.deleted_at) and is_nil(ep.deleted_at),
        select: %{user_id: ep.user_id}
      )

    # Second query: Events where user was participant - get organizers
    participant_organizers_query =
      from(ep in EventParticipant,
        join: e in Event,
        on: ep.event_id == e.id,
        join: eu in EventUser,
        on: e.id == eu.event_id,
        where:
          ep.user_id == ^user.id and eu.user_id != ^user.id and
            is_nil(e.deleted_at) and is_nil(ep.deleted_at) and is_nil(eu.deleted_at),
        select: %{user_id: eu.user_id}
      )

    # Third query: Events where user was participant - get other participants  
    participant_participants_query =
      from(ep1 in EventParticipant,
        join: e in Event,
        on: ep1.event_id == e.id,
        join: ep2 in EventParticipant,
        on: e.id == ep2.event_id,
        where:
          ep1.user_id == ^user.id and ep2.user_id != ^user.id and
            is_nil(e.deleted_at) and is_nil(ep1.deleted_at) and is_nil(ep2.deleted_at),
        select: %{user_id: ep2.user_id}
      )

    # Combine all queries with union and count distinct
    together_count =
      from(
        u in subquery(
          organizer_participants_query
          |> union(^participant_organizers_query)
          |> union(^participant_participants_query)
        ),
        select: count(u.user_id, :distinct)
      )
      |> Repo.one(with_deleted: true)

    %{
      hosted: hosted_count || 0,
      attended: attended_count || 0,
      together: together_count || 0
    }
  end

  @doc """
  Gets recent events for a user's profile (both hosted and attended).

  Options:
  - limit: Maximum number of events to return (default: 10)
  - include_future: Include future events (default: true)
  - public_only: Only return public events (default: false)
  """
  def get_user_recent_events(%User{} = user, opts \\ []) do
    alias EventasaurusApp.Events.{Event, EventUser, EventParticipant}
    import Ecto.Query

    limit = Keyword.get(opts, :limit, 10)
    include_future = Keyword.get(opts, :include_future, true)
    public_only = Keyword.get(opts, :public_only, false)

    # Build base query with conditional JOINs - more efficient than UNION
    base_query =
      from(e in Event,
        # LEFT JOIN for organizer relationship
        left_join: eu in EventUser,
        on: e.id == eu.event_id and eu.user_id == ^user.id and is_nil(eu.deleted_at),
        # LEFT JOIN for participant relationship
        left_join: ep in EventParticipant,
        on: e.id == ep.event_id and ep.user_id == ^user.id and is_nil(ep.deleted_at),
        # User must be either organizer or participant
        where:
          is_nil(e.deleted_at) and
            (not is_nil(eu.id) or not is_nil(ep.id)),
        select: %{
          id: e.id,
          title: e.title,
          tagline: e.tagline,
          start_at: e.start_at,
          ends_at: e.ends_at,
          timezone: e.timezone,
          slug: e.slug,
          cover_image_url: e.cover_image_url,
          external_image_data: e.external_image_data,
          status: e.status,
          visibility: e.visibility,
          venue_id: e.venue_id,
          # Determine user role with organizer priority
          user_role:
            fragment("CASE WHEN ? IS NOT NULL THEN 'organizer' ELSE 'attendee' END", eu.id),
          inserted_at: e.inserted_at,
          # For ordering - organizer takes priority
          role_priority: fragment("CASE WHEN ? IS NOT NULL THEN 1 ELSE 0 END", eu.id)
        },
        # Order by start_at desc, then by role priority (organizer first) for same event
        # Use the fragment directly in ORDER BY since role_priority is a computed field
        order_by: [
          desc_nulls_last: :start_at,
          desc: fragment("CASE WHEN ? IS NOT NULL THEN 1 ELSE 0 END", eu.id)
        ],
        # Use DISTINCT ON to ensure each event appears only once
        distinct: :id,
        limit: ^limit
      )

    # Apply conditional where clauses
    query =
      base_query
      |> maybe_filter_future_events(include_future)
      |> maybe_filter_public_only(public_only)

    events = Repo.all(query, with_deleted: true)

    # Add venue field set to nil for template compatibility
    # TODO: Load venues separately if needed by the template
    events
    |> Enum.map(fn event ->
      # Remove internal ordering field
      Map.drop(event, [:role_priority])
      |> Map.put(:venue, nil)
    end)
  end

  # Helper function to conditionally filter future events
  defp maybe_filter_future_events(query, true), do: query

  defp maybe_filter_future_events(query, false) do
    from([e, eu, ep] in query,
      where: is_nil(e.start_at) or e.start_at < ^DateTime.utc_now()
    )
  end

  # Helper function to conditionally filter for public events only
  defp maybe_filter_public_only(query, false), do: query

  defp maybe_filter_public_only(query, true) do
    from([e, eu, ep] in query,
      where: e.visibility == :public
    )
  end

  @doc """
  Gets mutual events between the current auth user and a profile user.

  This shows events that both users have been involved with (either as organizers or participants).
  Only returns public events or events where the auth user is also involved.
  """
  def get_mutual_events(%User{} = auth_user, %User{} = profile_user, opts \\ []) do
    alias EventasaurusApp.Events.{Event, EventUser, EventParticipant}
    import Ecto.Query

    limit = Keyword.get(opts, :limit, 6)

    # Find events where both users were involved - using a simpler approach with joins
    mutual_events_query =
      from(e in Event,
        left_join: v in assoc(e, :venue),
        # Join with EventUser for profile_user
        left_join: eu1 in EventUser,
        on: e.id == eu1.event_id and eu1.user_id == ^profile_user.id,
        # Join with EventParticipant for profile_user  
        left_join: ep1 in EventParticipant,
        on: e.id == ep1.event_id and ep1.user_id == ^profile_user.id,
        # Join with EventUser for auth_user
        left_join: eu2 in EventUser,
        on: e.id == eu2.event_id and eu2.user_id == ^auth_user.id,
        # Join with EventParticipant for auth_user
        left_join: ep2 in EventParticipant,
        on: e.id == ep2.event_id and ep2.user_id == ^auth_user.id,
        # Check soft deletes for joins
        # Profile user was involved (organizer or participant)
        # Auth user was also involved (organizer or participant)
        # Only show public events for mutual events
        where:
          is_nil(e.deleted_at) and
            (is_nil(eu1.deleted_at) or is_nil(eu1.id)) and
            (is_nil(ep1.deleted_at) or is_nil(ep1.id)) and
            (is_nil(eu2.deleted_at) or is_nil(eu2.id)) and
            (is_nil(ep2.deleted_at) or is_nil(ep2.id)) and
            (not is_nil(eu1.id) or not is_nil(ep1.id)) and
            (not is_nil(eu2.id) or not is_nil(ep2.id)) and
            e.visibility == :public,
        select: %{
          id: e.id,
          title: e.title,
          tagline: e.tagline,
          start_at: e.start_at,
          timezone: e.timezone,
          slug: e.slug,
          cover_image_url: e.cover_image_url,
          external_image_data: e.external_image_data,
          status: e.status,
          visibility: e.visibility,
          venue_id: e.venue_id
        },
        distinct: true,
        order_by: [desc: e.start_at],
        limit: ^limit
      )

    events = Repo.all(mutual_events_query, with_deleted: true)

    # Add venue field set to nil for template compatibility
    events
    |> Enum.map(fn event ->
      Map.put(event, :venue, nil)
    end)
  end

  @doc """
  Searches for users that can be added as event organizers.

  Searches by name, username, or email and only returns users with public profiles
  unless the searcher has admin privileges for the event. Supports pagination and
  limits results for performance and privacy.

  ## Parameters
  - query: String to search for in name, username, or email
  - opts: Keyword list with options
    - :limit - Maximum results to return (default: 20, max: 50)
    - :offset - Number of records to skip for pagination (default: 0)
    - :exclude_user_id - User ID to exclude from results (typically the searcher)
    - :include_private - Whether to include users with private profiles (default: false)
    - :event_id - Event ID to provide context for filtering (excludes existing organizers)
    - :requesting_user_id - User ID of the person making the request (for permission checking)

  ## Examples
      iex> search_users_for_organizers("john")
      [%User{name: "John Doe", username: "johndoe"}, ...]

      iex> search_users_for_organizers("john", limit: 10, exclude_user_id: 5, event_id: 123)
      [%User{name: "John Smith", username: "johnsmith"}, ...]
  """
  def search_users_for_organizers(query, opts \\ []) when is_binary(query) do
    # Cap at 50 for performance
    limit = Keyword.get(opts, :limit, 20) |> min(50)
    offset = Keyword.get(opts, :offset, 0)
    exclude_user_id = Keyword.get(opts, :exclude_user_id)
    include_private = Keyword.get(opts, :include_private, false)
    event_id = Keyword.get(opts, :event_id)
    requesting_user_id = Keyword.get(opts, :requesting_user_id)

    # Sanitize query - remove extra whitespace and limit length
    clean_query = query |> String.trim() |> String.slice(0, 100)

    # Return empty if query too short to avoid expensive searches
    if String.length(clean_query) < 2 do
      []
    else
      search_pattern = "%#{clean_query}%"

      base_query =
        from(u in User,
          where:
            ilike(u.name, ^search_pattern) or
              ilike(u.username, ^search_pattern) or
              ilike(u.email, ^search_pattern),
          limit: ^limit,
          offset: ^offset,
          order_by: [
            # Prioritize exact username matches, then name matches
            desc:
              fragment(
                "CASE WHEN lower(?) = lower(?) THEN 1 ELSE 0 END",
                u.username,
                ^clean_query
              ),
            desc:
              fragment("CASE WHEN lower(?) = lower(?) THEN 1 ELSE 0 END", u.name, ^clean_query),
            asc: u.name
          ],
          select: %{
            id: u.id,
            name: u.name,
            username: u.username,
            email: u.email,
            profile_public: u.profile_public
          }
        )

      # Add privacy filter - include private profiles if user can manage the event
      query_with_privacy =
        if include_private or can_see_private_profiles?(requesting_user_id, event_id) do
          base_query
        else
          from(u in base_query, where: u.profile_public == true)
        end

      # Exclude users who are already organizers of this event
      query_with_event_filter =
        if event_id do
          from(u in query_with_privacy,
            left_join: eu in EventasaurusApp.Events.EventUser,
            on: eu.user_id == u.id and eu.event_id == ^event_id,
            where: is_nil(eu.id)
          )
        else
          query_with_privacy
        end

      # Exclude specific user if provided
      final_query =
        if exclude_user_id do
          from(u in query_with_event_filter, where: u.id != ^exclude_user_id)
        else
          query_with_event_filter
        end

      Repo.all(final_query)
    end
  end

  # Helper function to determine if user can see private profiles
  defp can_see_private_profiles?(requesting_user_id, event_id) do
    # If no event context, can't see private profiles
    if is_nil(requesting_user_id) or is_nil(event_id) do
      false
    else
      # Check if requesting user can manage the event
      case get_user(requesting_user_id) do
        %User{} = user ->
          case EventasaurusApp.Events.get_event(event_id) do
            %EventasaurusApp.Events.Event{} = event ->
              EventasaurusApp.Events.user_can_manage_event?(user, event)

            _ ->
              false
          end

        _ ->
          false
      end
    end
  end

  @doc """
  Returns the safe public fields that can be exposed in search results.
  This provides explicit control over data exposure to prevent accidentally
  leaking sensitive information.
  """
  def safe_public_fields do
    [:id, :name, :username, :profile_public]
  end

  @doc """
  Returns the safe public fields plus email for authorized contexts.
  Only use when the requester has proper authorization.
  """
  def safe_public_fields_with_email do
    safe_public_fields() ++ [:email]
  end

  # Helper function to extract name from email consistently
  defp extract_name_from_email(email) when is_binary(email) do
    email
    |> String.split("@")
    |> List.first()
    |> String.capitalize()
  end

  defp extract_name_from_email(_), do: "User"

  # =============================================================================
  # User Preferences
  # =============================================================================

  @doc """
  Gets preferences for a user, creating default preferences if none exist.

  This is the primary function for accessing user preferences as it handles
  the common case of users who haven't explicitly set preferences yet.

  ## Examples

      iex> get_or_create_preferences(user)
      {:ok, %UserPreferences{connection_permission: :event_attendees}}
  """
  @spec get_or_create_preferences(User.t()) :: {:ok, UserPreferences.t()} | {:error, term()}
  def get_or_create_preferences(%User{id: user_id}) do
    case Repo.get_by(UserPreferences, user_id: user_id) do
      %UserPreferences{} = prefs ->
        {:ok, prefs}

      nil ->
        create_default_preferences(user_id)
    end
  end

  @doc """
  Gets preferences for a user, returning nil if none exist.

  Use this when you want to check preferences without auto-creating them.

  ## Examples

      iex> get_preferences(user)
      %UserPreferences{connection_permission: :event_attendees}

      iex> get_preferences(new_user)
      nil
  """
  @spec get_preferences(User.t()) :: UserPreferences.t() | nil
  def get_preferences(%User{id: user_id}) do
    Repo.get_by(UserPreferences, user_id: user_id)
  end

  @doc """
  Gets preferences for a user, returning default values if none exist.

  This is useful when you need to read preferences without database writes,
  such as in permission checks.

  ## Examples

      iex> get_preferences_or_defaults(user)
      %UserPreferences{connection_permission: :event_attendees}
  """
  @spec get_preferences_or_defaults(User.t()) :: UserPreferences.t()
  def get_preferences_or_defaults(%User{id: user_id} = user) do
    case Repo.get_by(UserPreferences, user_id: user_id) do
      %UserPreferences{} = prefs ->
        prefs

      nil ->
        # Return a struct with defaults (not persisted)
        %UserPreferences{
          user_id: user_id,
          user: user,
          connection_permission: :event_attendees,
          show_on_attendee_lists: true,
          discoverable_in_suggestions: true
        }
    end
  end

  @doc """
  Creates default preferences for a user.

  ## Examples

      iex> create_default_preferences(user_id)
      {:ok, %UserPreferences{}}
  """
  @spec create_default_preferences(integer()) :: {:ok, UserPreferences.t()} | {:error, term()}
  def create_default_preferences(user_id) when is_integer(user_id) do
    %UserPreferences{}
    |> UserPreferences.changeset(Map.put(UserPreferences.defaults(), :user_id, user_id))
    |> Repo.insert()
  end

  @doc """
  Updates a user's preferences.

  ## Examples

      iex> update_preferences(preferences, %{connection_permission: :closed})
      {:ok, %UserPreferences{connection_permission: :closed}}
  """
  @spec update_preferences(UserPreferences.t(), map()) ::
          {:ok, UserPreferences.t()} | {:error, Ecto.Changeset.t()}
  def update_preferences(%UserPreferences{} = preferences, attrs) do
    preferences
    |> UserPreferences.update_changeset(attrs)
    |> Repo.update()
  end

  @doc """
  Updates preferences for a user, creating them first if they don't exist.

  ## Examples

      iex> update_user_preferences(user, %{connection_permission: :open})
      {:ok, %UserPreferences{connection_permission: :open}}
  """
  @spec update_user_preferences(User.t(), map()) ::
          {:ok, UserPreferences.t()} | {:error, term()}
  def update_user_preferences(%User{} = user, attrs) do
    case get_or_create_preferences(user) do
      {:ok, preferences} ->
        update_preferences(preferences, attrs)

      {:error, reason} ->
        {:error, reason}
    end
  end

  @doc """
  Returns a changeset for tracking preference changes.

  ## Examples

      iex> change_preferences(preferences)
      #Ecto.Changeset<...>
  """
  @spec change_preferences(UserPreferences.t(), map()) :: Ecto.Changeset.t()
  def change_preferences(%UserPreferences{} = preferences, attrs \\ %{}) do
    UserPreferences.update_changeset(preferences, attrs)
  end

  @doc """
  Gets the connection permission level for a user.

  Returns the default (:event_attendees) if no preferences exist.

  ## Examples

      iex> get_connection_permission(user)
      :event_attendees
  """
  @spec get_connection_permission(User.t()) :: UserPreferences.connection_permission()
  def get_connection_permission(%User{} = user) do
    get_preferences_or_defaults(user).connection_permission
  end
end
