defmodule EventasaurusApp.Accounts do
  @moduledoc """
  The Accounts context.
  """

  import Ecto.Query, warn: false
  alias EventasaurusApp.Repo
  alias EventasaurusApp.Accounts.User

  @doc """
  Returns the list of users.
  """
  def list_users do
    Repo.all(User)
  end

  @doc """
  Gets a single user.

  Raises `Ecto.NoResultsError` if the User does not exist.
  """
  def get_user!(id), do: Repo.get!(User, id)

  @doc """
  Gets a single user.

  Returns nil if the User does not exist.
  """
  def get_user(id), do: Repo.get(User, id)

  @doc """
  Gets a user by email (case-insensitive).
  Returns nil if email is invalid or user not found.
  """
  def get_user_by_email(email) when is_binary(email) do
    case EventasaurusApp.Sanitizer.sanitize_email(email) do
      {:error, _reason} ->
        # Invalid email format, return nil
        nil

      nil ->
        nil

      normalized_email when is_binary(normalized_email) ->
        Repo.get_by(User, email: normalized_email)
    end
  end

  def get_user_by_email(_), do: nil

  @doc """
  Gets a user by Supabase ID.
  """
  def get_user_by_supabase_id(supabase_id) do
    Repo.get_by(User, supabase_id: supabase_id)
  end

  @doc """
  Gets a user by username (case-insensitive).
  """
  def get_user_by_username(username) when is_binary(username) do
    from(u in User, where: fragment("lower(?)", u.username) == ^String.downcase(username))
    |> Repo.one()
  end

  @doc """
  Gets a user by username or ID.
  First tries to find by username, then falls back to ID lookup.
  Also handles "user-{id}" patterns generated by User.username_slug/1 for users without usernames.
  """
  def get_user_by_username_or_id(identifier) when is_binary(identifier) do
    # First try username lookup
    case get_user_by_username(identifier) do
      %User{} = user ->
        user

      nil ->
        # Check if it's a "user-{id}" pattern from username_slug
        case Regex.run(~r/^user-(\d+)$/, identifier) do
          [_, id_str] ->
            case Integer.parse(id_str) do
              {id, ""} -> get_user(id)
              _ -> nil
            end

          nil ->
            # Try regular ID lookup if not a "user-{id}" pattern
            case Integer.parse(identifier) do
              {id, ""} -> get_user(id)
              _ -> nil
            end
        end
    end
  end

  @doc """
  Creates a user.
  """
  def create_user(attrs \\ %{}) do
    %User{}
    |> User.changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Updates a user.
  """
  def update_user(%User{} = user, attrs) do
    user
    |> User.changeset(attrs)
    |> Repo.update()
  end

  @doc """
  Deletes a user.
  """
  def delete_user(%User{} = user) do
    Repo.delete(user)
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking user changes.
  """
  def change_user(%User{} = user, attrs \\ %{}) do
    User.changeset(user, attrs)
  end

  @doc """
  Finds or creates a user from Supabase user data.
  Returns {:ok, user} or {:error, reason}.
  """
  def find_or_create_from_supabase(%{
        "id" => supabase_id,
        "email" => email,
        "user_metadata" => user_metadata
      }) do
    case get_user_by_supabase_id(supabase_id) do
      %User{} = user ->
        {:ok, user}

      nil ->
        # Normalize email to ensure consistency
        # Supabase should always provide valid emails, but we validate anyway
        case EventasaurusApp.Sanitizer.sanitize_email(email) do
          {:error, reason} ->
            # This shouldn't happen with Supabase, but handle it gracefully
            {:error, {:invalid_email, reason}}

          nil ->
            {:error, {:invalid_email, "Email is nil"}}

          normalized_email when is_binary(normalized_email) ->
            # Safely extract name from user_metadata
            name =
              case user_metadata do
                m when is_map(m) ->
                  Map.get(m, "name") || extract_name_from_email(normalized_email)

                _ ->
                  extract_name_from_email(normalized_email)
              end

            user_params = %{
              email: normalized_email,
              name: name,
              supabase_id: supabase_id
            }

            create_user(user_params)
        end
    end
  end

  def find_or_create_from_supabase(_), do: {:error, :invalid_supabase_data}

  @doc """
  Finds or creates a user by email for guest invitations.
  If the user doesn't exist, creates a minimal user record with the email.
  Returns {:ok, user} or {:error, reason}.
  """
  def find_or_create_guest_user(email) when is_binary(email) do
    # Normalize and validate the email first
    case EventasaurusApp.Sanitizer.sanitize_email(email) do
      {:error, reason} ->
        # Invalid email format
        {:error, {:invalid_email, reason}}

      nil ->
        {:error, {:invalid_email, "Email cannot be nil"}}

      normalized_email when is_binary(normalized_email) ->
        case get_user_by_email(normalized_email) do
          %User{} = user ->
            {:ok, user}

          nil ->
            name = extract_name_from_email(normalized_email)
            # Generate a temporary supabase_id for guest users
            temp_supabase_id = "guest_#{:crypto.strong_rand_bytes(8) |> Base.encode64()}"

            user_params = %{
              email: normalized_email,
              name: name,
              supabase_id: temp_supabase_id
            }

            create_user(user_params)
        end
    end
  end

  def find_or_create_guest_user(_), do: {:error, {:invalid_email, "Email must be a string"}}

  @doc """
  Search for users by name, username, or email.

  Options:
  - exclude_ids: List of user IDs to exclude from results
  - limit: Maximum number of results to return (default: 10)
  """
  def search_users(query, opts \\ []) when is_binary(query) do
    exclude_ids = Keyword.get(opts, :exclude_ids, [])
    limit = Keyword.get(opts, :limit, 10)

    search_query = String.trim(query)

    if search_query == "" do
      {:ok, []}
    else
      # Create search pattern for ILIKE
      search_pattern = "%#{search_query}%"

      users =
        from(u in User,
          where:
            (ilike(u.name, ^search_pattern) or
             ilike(u.username, ^search_pattern) or
             ilike(u.email, ^search_pattern)) and
            u.id not in ^exclude_ids,
          limit: ^limit,
          order_by: [
            # Prioritize exact matches
            fragment("CASE
              WHEN lower(?) = lower(?) THEN 0
              WHEN lower(?) = lower(?) THEN 0
              WHEN lower(?) = lower(?) THEN 0
              ELSE 1
            END", u.name, ^search_query, u.username, ^search_query, u.email, ^search_query),
            # Then prioritize starts-with matches
            fragment("CASE
              WHEN lower(?) LIKE lower(?) THEN 0
              WHEN lower(?) LIKE lower(?) THEN 0
              WHEN lower(?) LIKE lower(?) THEN 0
              ELSE 1
            END", u.name, ^"#{search_query}%", u.username, ^"#{search_query}%", u.email, ^"#{search_query}%"),
            # Finally order by name
            u.name
          ]
        )
        |> Repo.all()

      {:ok, users}
    end
  rescue
    _ -> {:error, :search_failed}
  end

  @doc """
  Gets user event statistics for profile display.

  Returns a map with:
  - hosted: Number of events the user has organized/hosted
  - attended: Number of events the user has attended
  - together: Number of unique other users they've shared events with
  """
  def get_user_event_stats(%User{} = user) do
    alias EventasaurusApp.Events.{Event, EventUser, EventParticipant}
    import Ecto.Query

    # Count hosted events (user is in event_users table)
    hosted_count =
      from(eu in EventUser,
        join: e in Event,
        on: eu.event_id == e.id,
        where: eu.user_id == ^user.id and is_nil(e.deleted_at) and is_nil(eu.deleted_at),
        select: count(e.id)
      )
      |> Repo.one(with_deleted: true)

    # Count attended events (user is in event_participants table)
    attended_count =
      from(ep in EventParticipant,
        join: e in Event,
        on: ep.event_id == e.id,
        where: ep.user_id == ^user.id and is_nil(e.deleted_at) and is_nil(ep.deleted_at),
        select: count(e.id, :distinct)
      )
      |> Repo.one(with_deleted: true)

    # Count unique other users they've shared events with (both as organizer and participant)
    # First query: Events where user was organizer - get other participants
    organizer_participants_query =
      from(eu in EventUser,
        join: e in Event,
        on: eu.event_id == e.id,
        join: ep in EventParticipant,
        on: e.id == ep.event_id,
        where:
          eu.user_id == ^user.id and ep.user_id != ^user.id and
            is_nil(e.deleted_at) and is_nil(eu.deleted_at) and is_nil(ep.deleted_at),
        select: %{user_id: ep.user_id}
      )

    # Second query: Events where user was participant - get organizers
    participant_organizers_query =
      from(ep in EventParticipant,
        join: e in Event,
        on: ep.event_id == e.id,
        join: eu in EventUser,
        on: e.id == eu.event_id,
        where:
          ep.user_id == ^user.id and eu.user_id != ^user.id and
            is_nil(e.deleted_at) and is_nil(ep.deleted_at) and is_nil(eu.deleted_at),
        select: %{user_id: eu.user_id}
      )

    # Third query: Events where user was participant - get other participants  
    participant_participants_query =
      from(ep1 in EventParticipant,
        join: e in Event,
        on: ep1.event_id == e.id,
        join: ep2 in EventParticipant,
        on: e.id == ep2.event_id,
        where:
          ep1.user_id == ^user.id and ep2.user_id != ^user.id and
            is_nil(e.deleted_at) and is_nil(ep1.deleted_at) and is_nil(ep2.deleted_at),
        select: %{user_id: ep2.user_id}
      )

    # Combine all queries with union and count distinct
    together_count =
      from(
        u in subquery(
          organizer_participants_query
          |> union(^participant_organizers_query)
          |> union(^participant_participants_query)
        ),
        select: count(u.user_id, :distinct)
      )
      |> Repo.one(with_deleted: true)

    %{
      hosted: hosted_count || 0,
      attended: attended_count || 0,
      together: together_count || 0
    }
  end

  @doc """
  Gets recent events for a user's profile (both hosted and attended).

  Options:
  - limit: Maximum number of events to return (default: 10)
  - include_future: Include future events (default: true)
  - public_only: Only return public events (default: false)
  """
  def get_user_recent_events(%User{} = user, opts \\ []) do
    alias EventasaurusApp.Events.{Event, EventUser, EventParticipant}
    import Ecto.Query

    limit = Keyword.get(opts, :limit, 10)
    include_future = Keyword.get(opts, :include_future, true)
    public_only = Keyword.get(opts, :public_only, false)

    # Build base query with conditional JOINs - more efficient than UNION
    base_query =
      from(e in Event,
        # LEFT JOIN for organizer relationship
        left_join: eu in EventUser,
        on: e.id == eu.event_id and eu.user_id == ^user.id and is_nil(eu.deleted_at),
        # LEFT JOIN for participant relationship
        left_join: ep in EventParticipant,
        on: e.id == ep.event_id and ep.user_id == ^user.id and is_nil(ep.deleted_at),
        # User must be either organizer or participant
        where:
          is_nil(e.deleted_at) and
            (not is_nil(eu.id) or not is_nil(ep.id)),
        select: %{
          id: e.id,
          title: e.title,
          tagline: e.tagline,
          start_at: e.start_at,
          ends_at: e.ends_at,
          timezone: e.timezone,
          slug: e.slug,
          cover_image_url: e.cover_image_url,
          external_image_data: e.external_image_data,
          status: e.status,
          visibility: e.visibility,
          venue_id: e.venue_id,
          # Determine user role with organizer priority
          user_role:
            fragment("CASE WHEN ? IS NOT NULL THEN 'organizer' ELSE 'attendee' END", eu.id),
          inserted_at: e.inserted_at,
          # For ordering - organizer takes priority
          role_priority: fragment("CASE WHEN ? IS NOT NULL THEN 1 ELSE 0 END", eu.id)
        },
        # Order by start_at desc, then by role priority (organizer first) for same event
        # Use the fragment directly in ORDER BY since role_priority is a computed field
        order_by: [
          desc: :start_at,
          desc: fragment("CASE WHEN ? IS NOT NULL THEN 1 ELSE 0 END", eu.id)
        ],
        # Use DISTINCT ON to ensure each event appears only once
        distinct: :id,
        limit: ^limit
      )

    # Apply conditional where clauses
    query =
      base_query
      |> maybe_filter_future_events(include_future)
      |> maybe_filter_public_only(public_only)

    events = Repo.all(query, with_deleted: true)

    # Add venue field set to nil for template compatibility
    # TODO: Load venues separately if needed by the template
    events
    |> Enum.map(fn event ->
      # Remove internal ordering field
      Map.drop(event, [:role_priority])
      |> Map.put(:venue, nil)
    end)
  end

  # Helper function to conditionally filter future events
  defp maybe_filter_future_events(query, true), do: query

  defp maybe_filter_future_events(query, false) do
    from([e, eu, ep] in query,
      where: is_nil(e.start_at) or e.start_at < ^DateTime.utc_now()
    )
  end

  # Helper function to conditionally filter for public events only
  defp maybe_filter_public_only(query, false), do: query

  defp maybe_filter_public_only(query, true) do
    from([e, eu, ep] in query,
      where: e.visibility == :public
    )
  end

  @doc """
  Gets mutual events between the current auth user and a profile user.

  This shows events that both users have been involved with (either as organizers or participants).
  Only returns public events or events where the auth user is also involved.
  """
  def get_mutual_events(%User{} = auth_user, %User{} = profile_user, opts \\ []) do
    alias EventasaurusApp.Events.{Event, EventUser, EventParticipant}
    import Ecto.Query

    limit = Keyword.get(opts, :limit, 6)

    # Find events where both users were involved - using a simpler approach with joins
    mutual_events_query =
      from(e in Event,
        left_join: v in assoc(e, :venue),
        # Join with EventUser for profile_user
        left_join: eu1 in EventUser,
        on: e.id == eu1.event_id and eu1.user_id == ^profile_user.id,
        # Join with EventParticipant for profile_user  
        left_join: ep1 in EventParticipant,
        on: e.id == ep1.event_id and ep1.user_id == ^profile_user.id,
        # Join with EventUser for auth_user
        left_join: eu2 in EventUser,
        on: e.id == eu2.event_id and eu2.user_id == ^auth_user.id,
        # Join with EventParticipant for auth_user
        left_join: ep2 in EventParticipant,
        on: e.id == ep2.event_id and ep2.user_id == ^auth_user.id,
        # Check soft deletes for joins
        # Profile user was involved (organizer or participant)
        # Auth user was also involved (organizer or participant)
        # Only show public events for mutual events
        where:
          is_nil(e.deleted_at) and
            (is_nil(eu1.deleted_at) or is_nil(eu1.id)) and
            (is_nil(ep1.deleted_at) or is_nil(ep1.id)) and
            (is_nil(eu2.deleted_at) or is_nil(eu2.id)) and
            (is_nil(ep2.deleted_at) or is_nil(ep2.id)) and
            (not is_nil(eu1.id) or not is_nil(ep1.id)) and
            (not is_nil(eu2.id) or not is_nil(ep2.id)) and
            e.visibility == :public,
        select: %{
          id: e.id,
          title: e.title,
          tagline: e.tagline,
          start_at: e.start_at,
          timezone: e.timezone,
          slug: e.slug,
          cover_image_url: e.cover_image_url,
          external_image_data: e.external_image_data,
          status: e.status,
          visibility: e.visibility,
          venue_id: e.venue_id
        },
        distinct: true,
        order_by: [desc: e.start_at],
        limit: ^limit
      )

    events = Repo.all(mutual_events_query, with_deleted: true)

    # Add venue field set to nil for template compatibility
    events
    |> Enum.map(fn event ->
      Map.put(event, :venue, nil)
    end)
  end

  @doc """
  Searches for users that can be added as event organizers.

  Searches by name, username, or email and only returns users with public profiles
  unless the searcher has admin privileges for the event. Supports pagination and
  limits results for performance and privacy.

  ## Parameters
  - query: String to search for in name, username, or email
  - opts: Keyword list with options
    - :limit - Maximum results to return (default: 20, max: 50)
    - :offset - Number of records to skip for pagination (default: 0)
    - :exclude_user_id - User ID to exclude from results (typically the searcher)
    - :include_private - Whether to include users with private profiles (default: false)
    - :event_id - Event ID to provide context for filtering (excludes existing organizers)
    - :requesting_user_id - User ID of the person making the request (for permission checking)

  ## Examples
      iex> search_users_for_organizers("john")
      [%User{name: "John Doe", username: "johndoe"}, ...]

      iex> search_users_for_organizers("john", limit: 10, exclude_user_id: 5, event_id: 123)
      [%User{name: "John Smith", username: "johnsmith"}, ...]
  """
  def search_users_for_organizers(query, opts \\ []) when is_binary(query) do
    # Cap at 50 for performance
    limit = Keyword.get(opts, :limit, 20) |> min(50)
    offset = Keyword.get(opts, :offset, 0)
    exclude_user_id = Keyword.get(opts, :exclude_user_id)
    include_private = Keyword.get(opts, :include_private, false)
    event_id = Keyword.get(opts, :event_id)
    requesting_user_id = Keyword.get(opts, :requesting_user_id)

    # Sanitize query - remove extra whitespace and limit length
    clean_query = query |> String.trim() |> String.slice(0, 100)

    # Return empty if query too short to avoid expensive searches
    if String.length(clean_query) < 2 do
      []
    else
      search_pattern = "%#{clean_query}%"

      base_query =
        from(u in User,
          where:
            ilike(u.name, ^search_pattern) or
              ilike(u.username, ^search_pattern) or
              ilike(u.email, ^search_pattern),
          limit: ^limit,
          offset: ^offset,
          order_by: [
            # Prioritize exact username matches, then name matches
            desc:
              fragment(
                "CASE WHEN lower(?) = lower(?) THEN 1 ELSE 0 END",
                u.username,
                ^clean_query
              ),
            desc:
              fragment("CASE WHEN lower(?) = lower(?) THEN 1 ELSE 0 END", u.name, ^clean_query),
            asc: u.name
          ],
          select: %{
            id: u.id,
            name: u.name,
            username: u.username,
            email: u.email,
            profile_public: u.profile_public
          }
        )

      # Add privacy filter - include private profiles if user can manage the event
      query_with_privacy =
        if include_private or can_see_private_profiles?(requesting_user_id, event_id) do
          base_query
        else
          from(u in base_query, where: u.profile_public == true)
        end

      # Exclude users who are already organizers of this event
      query_with_event_filter =
        if event_id do
          from(u in query_with_privacy,
            left_join: eu in EventasaurusApp.Events.EventUser,
            on: eu.user_id == u.id and eu.event_id == ^event_id,
            where: is_nil(eu.id)
          )
        else
          query_with_privacy
        end

      # Exclude specific user if provided
      final_query =
        if exclude_user_id do
          from(u in query_with_event_filter, where: u.id != ^exclude_user_id)
        else
          query_with_event_filter
        end

      Repo.all(final_query)
    end
  end

  # Helper function to determine if user can see private profiles
  defp can_see_private_profiles?(requesting_user_id, event_id) do
    # If no event context, can't see private profiles
    if is_nil(requesting_user_id) or is_nil(event_id) do
      false
    else
      # Check if requesting user can manage the event
      case get_user(requesting_user_id) do
        %User{} = user ->
          case EventasaurusApp.Events.get_event(event_id) do
            %EventasaurusApp.Events.Event{} = event ->
              EventasaurusApp.Events.user_can_manage_event?(user, event)

            _ ->
              false
          end

        _ ->
          false
      end
    end
  end

  @doc """
  Returns the safe public fields that can be exposed in search results.
  This provides explicit control over data exposure to prevent accidentally
  leaking sensitive information.
  """
  def safe_public_fields do
    [:id, :name, :username, :profile_public]
  end

  @doc """
  Returns the safe public fields plus email for authorized contexts.
  Only use when the requester has proper authorization.
  """
  def safe_public_fields_with_email do
    safe_public_fields() ++ [:email]
  end

  # Helper function to extract name from email consistently
  defp extract_name_from_email(email) when is_binary(email) do
    email
    |> String.split("@")
    |> List.first()
    |> String.capitalize()
  end

  defp extract_name_from_email(_), do: "User"
end
