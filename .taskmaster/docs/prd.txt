# Eventasaurus Dynamic Social Card Generation PRD

## Project Overview
Implement dynamic social card generation for Eventasaurus events, similar to Lu.ma's approach. Generate Open Graph-compatible social preview images (PNG) dynamically when requested via URL, ensuring real-time reflection of event data and proper cache invalidation for social platforms.

## Goals & Objectives
- **Primary Goal**: Dynamically generate social preview images for each event on-demand
- **Cache Management**: Implement filename versioning to force Facebook/social platform cache invalidation when events change
- **Performance**: Render images on-the-fly using SVG templates converted to PNG
- **Compatibility**: Ensure Open Graph and Twitter Card compatibility
- **Maintainability**: Use Phoenix/Elixir templating system for easy customization

## Technical Requirements

### Core Architecture
- **Template System**: Use .svg.eex templates for dynamic SVG rendering
- **Image Processing**: Convert SVG to PNG using rsvg-convert system command
- **Runtime Generation**: No pre-generation - create images on request only
- **Phoenix Integration**: Deliver via Phoenix controller routes
- **File Management**: Temporary file handling with cleanup

### Image Specifications
- **Canvas Size**: 800Ã—419 pixels (1.91:1 aspect ratio for OG/Twitter)
- **Layout Padding**: 32px margin around content
- **Event Image**: 350Ã—350px positioned top-right with 24px rounded corners
- **Title Text**: Left-aligned, up to 3 lines, bold, 40-48px font size
- **Logo**: Eventasaurus dino logo, 64Ã—64px, positioned top-left
- **RSVP Bubble**: 80Ã—32px pill-shaped button, bottom-left positioning

### SVG Template Elements
1. **Gradient Background**: Dynamic gradient using theme.color1 and theme.color2
2. **Event Image**: Rendered from event.image_url with rounded corners via clipPath
3. **Logo**: Static Eventasaurus dino asset
4. **Title**: Dynamic text block from event.title
5. **RSVP Bubble**: White-filled rounded rectangle with centered "RSVP" text

### Cache Busting Strategy
- **Filename Versioning**: Include MD5 hash of event.image_url + event.updated_at
- **Hash Length**: 8-character truncated hash for manageable filenames
- **URL Pattern**: `/social_cards/{event_id}-{image_hash}.png`
- **Auto-Invalidation**: New URLs generated when event data changes

### Security Requirements
- **Input Validation**: Sanitize all dynamic content before SVG rendering
- **Access Control**: Consider signed URLs or UUID-based access for public cards
- **Injection Prevention**: Validate and escape all user-provided data

## Technical Implementation Flow

### Step 1: SVG Template Rendering
```elixir
svg = Phoenix.View.render_to_string(MyAppWeb.SocialCardView, "card.svg", 
  event: event, theme: theme)
```

### Step 2: Temporary File Management
```elixir
svg_path = "/tmp/eventasaurus_#{event.id}_#{event.image_hash}.svg"
File.write!(svg_path, svg)
```

### Step 3: PNG Conversion
```elixir
png_path = String.replace(svg_path, ".svg", ".png")
System.cmd("rsvg-convert", [svg_path, "-o", png_path])
```

### Step 4: HTTP Response
```elixir
conn
|> put_resp_content_type("image/png")
|> send_file(200, png_path)
```

### Hash Generation Algorithm
```elixir
image_hash = :crypto.hash(:md5, event.image_url <> to_string(event.updated_at))
  |> Base.encode16(case: :lower)
  |> binary_part(0, 8)
```

## Dependencies & Prerequisites
- **rsvg-convert**: System dependency for SVG to PNG conversion
- **Phoenix Framework**: For templating and HTTP handling
- **Elixir/Erlang**: Runtime environment
- **File System**: Temporary directory access with write permissions

## Route & Controller Structure
- **Route**: GET `/events/:id/social_card.png`
- **Controller**: EventSocialCardController
- **Action**: generate_card/2
- **Template**: `social_card/card.svg.eex`

## Error Handling
- **Missing Events**: Return 404 for non-existent events
- **Image Processing Failures**: Fallback to default/placeholder image
- **File System Issues**: Graceful degradation with error logging
- **Template Errors**: Validate data before rendering

## Performance Considerations
- **Temporary File Cleanup**: Implement cleanup mechanism for generated files
- **Concurrent Requests**: Handle multiple simultaneous card generation requests
- **Resource Limits**: Monitor memory usage during SVG/PNG processing
- **Response Caching**: Consider HTTP caching headers for generated images

## Testing Requirements
- **Unit Tests**: SVG template rendering with various event data
- **Integration Tests**: Full PNG generation pipeline
- **Visual Tests**: Verify output matches design specifications
- **Security Tests**: Validate input sanitization and injection prevention
- **Performance Tests**: Load testing for concurrent card generation

## Deployment Considerations
- **System Dependencies**: Ensure rsvg-convert is available in production
- **File Permissions**: Temporary directory write access
- **Resource Monitoring**: Track file system usage and cleanup
- **Error Logging**: Comprehensive logging for debugging production issues

## Success Metrics
- **Functional**: Cards generate successfully for all events
- **Performance**: Sub-2-second response times for card generation
- **Cache Invalidation**: Facebook/social platforms show updated cards within 24 hours
- **Error Rate**: <1% failure rate for card generation requests
- **Visual Quality**: Generated cards match design specifications exactly

## Future Enhancements
- **Template Variations**: Multiple card layouts/themes
- **Customization**: Event-specific styling options
- **Optimization**: Pre-generation for high-traffic events
- **Analytics**: Track social card usage and click-through rates

## Event Polling UI & Schema Redesign

### Current State
- Events currently use a fixed start_at/end_at datetime model
- Users must define specific start and end times at event creation
- Limited flexibility for gathering input on multiple possible dates
- UI uses basic datetime pickers

### Target Objectives
1. Allow users to suggest and vote on multiple possible dates for an event
2. Remove requirement to define a specific start_at or end_at at event creation
3. Change the UI to support a calendar-style system for choosing dates
4. Maintain existing database schema and validation logic
5. Create a more engaging and flexible event planning experience

### Technical Requirements

#### UI/UX Changes
1. Replace datetime picker with a calendar-style date selection system
2. Allow users to select 2 or more date options visually on a calendar interface
3. Remove the current date range selection in favor of cherry-picking specific dates
4. Display selected dates in a clear list format after selection
5. Implement voting interface with preference options:
   - âœ… Preferred
   - ðŸ¤· If Needed  
   - âŒ Not Available
6. Show vote tallies and popularity scores
7. Display heatmap or tallied result view for organizers

#### Backend Logic
1. Maintain existing database schema - no schema changes required
2. Continue using existing date creation logic and database storage
3. Store dates immediately after selection (same as current behavior)
4. Use median or most selected date as stand-in start_at for validation
5. Preserve all existing validation logic
6. Support multiple date storage using current date model

#### Event States (Future Enhancement)
Prepare foundation for these event states:
- draft
- polling  
- confirmed
- cancelled
- recruiting (not enough interest)
- closed (past event)
- rescheduling

### Functional Specifications

#### Date Selection Flow
1. User creates new event
2. Instead of start/end datetime pickers, user sees calendar interface
3. User clicks on 2+ dates on calendar to select possible event dates
4. Selected dates appear in a list below calendar
5. System stores these dates using existing date creation logic
6. For validation purposes, system calculates median date as temporary start_at

#### Voting Flow
1. Invitees receive event with multiple date options
2. For each date option, invitees can select preference level
3. Votes are recorded and tallied in real-time
4. Organizer can view results in heatmap or summary format
5. Most popular/median date becomes candidate for final validation

#### Organizer Controls
1. Organizer can always override and select final date manually
2. Organizer can see vote visibility and popularity previews
3. Organizer can add/remove date options during polling phase

### Technical Constraints
1. NO database schema changes - use existing date storage model
2. Maintain all existing validation logic
3. UI changes only - backend date handling remains the same
4. Must work with current Phoenix/Elixir stack
5. Calendar interface should be responsive and accessible

### Reference Design
Use Rallly.co as UI inspiration for calendar-based date selection and voting interface.

### Acceptance Criteria
1. Users can select multiple dates via calendar interface instead of datetime pickers
2. Selected dates are stored using existing database logic
3. Voting system allows preference selection for each date option
4. Organizer can view vote results and make final date selection
5. All existing validation continues to work with median date calculation
6. UI is responsive and accessible
7. No breaking changes to existing event creation flow
8. Calendar interface supports easy date selection and deselection

### Deliverables
1. New calendar-based date selection component
2. Date voting interface for invitees
3. Vote results dashboard for organizers
4. Updated event creation flow
5. Integration with existing validation system
6. Responsive UI implementation
7. Testing for all new functionality

### Timeline Considerations
This is a UI-focused change that should maintain existing backend logic, making it primarily a frontend development effort with minimal backend modifications needed for vote storage and retrieval. 