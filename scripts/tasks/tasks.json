{
  "tasks": [
    {
      "id": 1,
      "title": "Database Schema Updates for Theme Support",
      "description": "Update the Event model schema to include theme and theme_customizations fields as specified in the PRD.",
      "details": "Create a migration to add the theme enum field and theme_customizations JSONB field to the Event schema. The theme field should be an Ecto.Enum with values [:minimal, :cosmic, :velocity, :retro, :celebration, :nature, :professional] with a default of :minimal. The theme_customizations field should be a map with a default empty map. Update existing events to use the 'minimal' theme.\n\nExample migration:\n```elixir\ndefmodule EventasaurusApp.Repo.Migrations.AddThemeFieldsToEvents do\n  use Ecto.Migration\n\n  def change do\n    alter table(:events) do\n      add :theme, :string, default: \"minimal\"\n      add :theme_customizations, :map, default: %{}\n    end\n\n    create index(:events, [:theme])\n    \n    # Update existing events\n    execute \"UPDATE events SET theme = 'minimal' WHERE theme IS NULL\"\n  end\nend\n```\n\nUpdate Event schema:\n```elixir\ndefmodule EventasaurusApp.Events.Event do\n  # existing schema code...\n  \n  schema \"events\" do\n    # existing fields...\n    field :theme, Ecto.Enum, values: [:minimal, :cosmic, :velocity, :retro, :celebration, :nature, :professional], default: :minimal\n    field :theme_customizations, :map, default: %{}\n    # remaining fields...\n  end\n  \n  # Update changeset function to handle theme fields\n  def changeset(event, attrs) do\n    event\n    |> cast(attrs, [...existing_fields..., :theme, :theme_customizations])\n    |> validate_required([...existing_required_fields...])\n    |> validate_theme_customizations()\n  end\n  \n  defp validate_theme_customizations(changeset) do\n    # Add validation logic for theme customizations\n    changeset\n  end\nend\n```",
      "testStrategy": "1. Write unit tests to verify the Event schema correctly defines theme and theme_customizations fields\n2. Test that the changeset validation works correctly for valid and invalid theme values\n3. Write a migration test to ensure existing events are properly updated\n4. Test that the default values are correctly applied\n5. Verify that the database indexes are created correctly",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Themes Context Implementation",
      "description": "Create a Themes context module with utility functions for theme validation, customization merging, and default theme values.",
      "details": "Implement the Themes context module as specified in REQ-4.3.1 with functions for theme validation, customization merging, and retrieving default theme values.\n\n```elixir\ndefmodule EventasaurusApp.Themes do\n  @moduledoc \"\"\"\n  The Themes context provides utilities for working with event themes.\n  \"\"\"\n  \n  @theme_values [:minimal, :cosmic, :velocity, :retro, :celebration, :nature, :professional]\n  \n  @doc \"\"\"\n  Validates if a theme is valid.\n  \"\"\"\n  @spec valid_theme?(atom()) :: boolean()\n  def valid_theme?(theme) when theme in @theme_values, do: true\n  def valid_theme?(_), do: false\n  \n  @doc \"\"\"\n  Merges custom theme settings with base theme defaults.\n  \"\"\"\n  @spec merge_customizations(atom(), map()) :: map()\n  def merge_customizations(theme, customizations) do\n    Map.merge(get_default_customizations(theme), customizations || %{})\n  end\n  \n  @doc \"\"\"\n  Validates theme customizations for proper structure and values.\n  \"\"\"\n  @spec validate_customizations(map()) :: {:ok, map()} | {:error, String.t()}\n  def validate_customizations(customizations) do\n    # Implement validation logic for customization structure\n    # Check color formats, font values, etc.\n    {:ok, customizations}\n  end\n  \n  @doc \"\"\"\n  Returns the CSS class name for a given theme.\n  \"\"\"\n  @spec get_theme_css_class(atom()) :: String.t()\n  def get_theme_css_class(theme) when theme in @theme_values do\n    \"theme-#{theme}\"\n  end\n  def get_theme_css_class(_), do: \"theme-minimal\"\n  \n  @doc \"\"\"\n  Returns the default customizations for a given theme.\n  \"\"\"\n  @spec get_default_customizations(atom()) :: map()\n  def get_default_customizations(:minimal) do\n    %{\n      \"colors\" => %{\n        \"primary\" => \"#000000\",\n        \"secondary\" => \"#333333\",\n        \"accent\" => \"#0066cc\",\n        \"background\" => \"#ffffff\",\n        \"text\" => \"#000000\"\n      },\n      \"typography\" => %{\n        \"font_family\" => \"Inter\",\n        \"heading_weight\" => \"600\",\n        \"body_size\" => \"16px\"\n      },\n      \"layout\" => %{\n        \"border_radius\" => \"4px\",\n        \"shadow_style\" => \"soft\"\n      },\n      \"mode\" => \"light\"\n    }\n  end\n  \n  # Implement default customizations for other themes\n  def get_default_customizations(:cosmic) do\n    # Cosmic theme defaults\n  end\n  \n  # Add remaining theme default implementations\n  \n  # Fallback for unknown themes\n  def get_default_customizations(_), do: get_default_customizations(:minimal)\nend\n```\n\nAlso update the Events context to include theme-related functions:\n\n```elixir\ndefmodule EventasaurusApp.Events do\n  # Existing context code...\n  \n  alias EventasaurusApp.Themes\n  \n  @doc \"\"\"\n  Updates an event's theme.\n  \"\"\"\n  def update_event_theme(event, theme) when is_atom(theme) do\n    if Themes.valid_theme?(theme) do\n      event\n      |> Event.changeset(%{theme: theme})\n      |> Repo.update()\n    else\n      {:error, \"Invalid theme\"}\n    end\n  end\n  \n  @doc \"\"\"\n  Updates an event's theme customizations.\n  \"\"\"\n  def update_event_theme_customizations(event, customizations) do\n    case Themes.validate_customizations(customizations) do\n      {:ok, valid_customizations} ->\n        event\n        |> Event.changeset(%{theme_customizations: valid_customizations})\n        |> Repo.update()\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n  \n  @doc \"\"\"\n  Gets the complete theme data for an event, merging defaults with customizations.\n  \"\"\"\n  def get_event_theme_data(event) do\n    Themes.merge_customizations(event.theme, event.theme_customizations)\n  end\nend\n```",
      "testStrategy": "1. Write unit tests for each function in the Themes context\n2. Test valid_theme? with valid and invalid themes\n3. Test merge_customizations with various customization scenarios\n4. Test validate_customizations with valid and invalid customization data\n5. Test get_theme_css_class returns correct class names\n6. Test get_default_customizations returns proper defaults for each theme\n7. Test the Events context theme-related functions\n8. Verify theme validation works correctly in the Events context",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "CSS Architecture Setup for Themes",
      "description": "Establish the CSS architecture for themes including base styles, theme-specific CSS files, and CSS custom properties.",
      "details": "Create the CSS architecture as specified in REQ-4.2.1 and REQ-4.2.2. Set up the directory structure and implement the base theme foundation with CSS custom properties.\n\n1. Create the directory structure:\n```\nassets/css/\n├── themes/\n│   ├── base.css              # Shared theme foundation\n│   ├── minimal.css           # Minimal theme\n│   ├── cosmic.css            # Cosmic theme\n│   ├── velocity.css          # Velocity theme\n│   ├── retro.css             # Retro theme\n│   ├── celebration.css       # Celebration theme\n│   ├── nature.css            # Nature theme\n│   └── professional.css      # Professional theme\n└── public.css                # Base public styles\n```\n\n2. Implement base.css with CSS custom properties:\n```css\n/* Base theme foundation */\n:root {\n  /* Default theme variables (minimal theme) */\n  --theme-primary-color: #000000;\n  --theme-secondary-color: #333333;\n  --theme-accent-color: #0066cc;\n  --theme-background-color: #ffffff;\n  --theme-text-color: #000000;\n  \n  --theme-font-family: 'Inter', sans-serif;\n  --theme-heading-weight: 600;\n  --theme-body-size: 16px;\n  \n  --theme-border-radius: 4px;\n  --theme-shadow-style: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n/* Base theme styles that apply to all themes */\n.event-page {\n  font-family: var(--theme-font-family);\n  font-size: var(--theme-body-size);\n  color: var(--theme-text-color);\n  background-color: var(--theme-background-color);\n}\n\n.event-page h1, .event-page h2, .event-page h3 {\n  font-weight: var(--theme-heading-weight);\n}\n\n.event-page .btn-primary {\n  background-color: var(--theme-primary-color);\n  color: white;\n  border-radius: var(--theme-border-radius);\n}\n\n.event-page .card {\n  border-radius: var(--theme-border-radius);\n  box-shadow: var(--theme-shadow-style);\n}\n\n/* Theme mode support */\n.theme-dark {\n  --theme-text-color: #ffffff;\n  --theme-background-color: #121212;\n  /* Other dark mode overrides */\n}\n```\n\n3. Implement minimal.css (example):\n```css\n/* Minimal theme */\n.theme-minimal {\n  --theme-primary-color: #000000;\n  --theme-secondary-color: #333333;\n  --theme-accent-color: #0066cc;\n  --theme-background-color: #ffffff;\n  --theme-text-color: #000000;\n  \n  --theme-font-family: 'Inter', sans-serif;\n  --theme-heading-weight: 600;\n  --theme-body-size: 16px;\n  \n  --theme-border-radius: 4px;\n  --theme-shadow-style: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n/* Minimal theme specific styles */\n.theme-minimal .event-header {\n  border-bottom: 1px solid #eaeaea;\n}\n\n.theme-minimal .event-description {\n  line-height: 1.6;\n}\n```\n\n4. Create similar CSS files for each theme with appropriate custom properties and theme-specific styles\n\n5. Update the webpack/esbuild configuration to include these CSS files\n\n6. Implement a mechanism to load only the required theme CSS based on the event's theme",
      "testStrategy": "1. Verify CSS files compile correctly without errors\n2. Test that CSS custom properties are properly defined and accessible\n3. Check that theme-specific styles don't conflict with each other\n4. Test browser compatibility across major browsers\n5. Verify that the CSS architecture follows BEM or similar methodology\n6. Test that themes don't conflict with admin/dashboard styles\n7. Measure CSS bundle size to ensure it meets performance requirements (<50KB total)",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Theme Application to Public Event Pages",
      "description": "Implement the mechanism to apply the selected theme and customizations to public event pages.",
      "details": "Modify the PublicEventLive LiveView to apply the selected theme and customizations to the public event page. This includes loading the appropriate CSS and applying theme-specific classes and styles.\n\n1. Update the PublicEventLive module:\n```elixir\ndefmodule EventasaurusAppWeb.PublicEventLive do\n  use EventasaurusAppWeb, :live_view\n  alias EventasaurusApp.Events\n  alias EventasaurusApp.Themes\n  \n  # Existing code...\n  \n  @impl true\n  def mount(%{\"slug\" => slug}, _session, socket) do\n    case Events.get_event_by_slug(slug) do\n      nil ->\n        {:ok, socket |> put_flash(:error, \"Event not found\") |> redirect(to: \"/\")}\n      event ->\n        theme_data = Events.get_event_theme_data(event)\n        theme_class = Themes.get_theme_css_class(event.theme)\n        \n        {:ok, \n         socket\n         |> assign(:event, event)\n         |> assign(:page_title, event.title)\n         |> assign(:theme_class, theme_class)\n         |> assign(:theme_data, theme_data)}\n    end\n  end\n  \n  # Existing code...\nend\n```\n\n2. Update the PublicEventLive template to apply the theme class and custom styles:\n```heex\n<div class={[\"event-page\", @theme_class]}>\n  <!-- Existing template code... -->\n</div>\n\n<style>\n  :root {\n    /* Apply custom theme properties from theme_data */\n    --theme-primary-color: <%= @theme_data[\"colors\"][\"primary\"] %>;\n    --theme-secondary-color: <%= @theme_data[\"colors\"][\"secondary\"] %>;\n    --theme-accent-color: <%= @theme_data[\"colors\"][\"accent\"] %>;\n    --theme-background-color: <%= @theme_data[\"colors\"][\"background\"] %>;\n    --theme-text-color: <%= @theme_data[\"colors\"][\"text\"] %>;\n    \n    --theme-font-family: <%= @theme_data[\"typography\"][\"font_family\"] %>;\n    --theme-heading-weight: <%= @theme_data[\"typography\"][\"heading_weight\"] %>;\n    --theme-body-size: <%= @theme_data[\"typography\"][\"body_size\"] %>;\n    \n    --theme-border-radius: <%= @theme_data[\"layout\"][\"border_radius\"] %>;\n    /* Other custom properties... */\n  }\n</style>\n```\n\n3. Update the root layout to include theme CSS files:\n```elixir\ndefmodule EventasaurusAppWeb.Layouts do\n  use EventasaurusAppWeb, :html\n  \n  # Existing code...\n  \n  def public_event(assigns) do\n    ~H\"\"\"\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <!-- Existing head content... -->\n        <link rel=\"stylesheet\" href={~p\"/assets/css/public.css\"} />\n        <link rel=\"stylesheet\" href={~p\"/assets/css/themes/base.css\"} />\n        <!-- Theme-specific CSS will be loaded dynamically -->\n      </head>\n      <body>\n        <%= @inner_content %>\n      </body>\n    </html>\n    \"\"\"\n  end\nend\n```\n\n4. Create a helper function to dynamically load theme-specific CSS:\n```elixir\ndefmodule EventasaurusAppWeb.ThemeHelpers do\n  @doc \"\"\"\n  Returns the theme CSS path for a given theme.\n  \"\"\"\n  def theme_css_path(theme) do\n    \"/assets/css/themes/#{theme}.css\"\n  end\n  \n  @doc \"\"\"\n  Generates inline CSS for theme customizations.\n  \"\"\"\n  def generate_theme_css(theme_data) do\n    # Generate CSS custom properties from theme_data\n    # This is an alternative to the inline style approach\n  end\nend\n```\n\n5. Update the app.js to handle theme mode toggling (light/dark):\n```javascript\n// Theme mode handling\ndocument.addEventListener('DOMContentLoaded', () => {\n  const eventPage = document.querySelector('.event-page');\n  if (eventPage) {\n    const themeMode = eventPage.dataset.themeMode || 'light';\n    if (themeMode === 'dark') {\n      eventPage.classList.add('theme-dark');\n    }\n  }\n});\n```",
      "testStrategy": "1. Test that the correct theme class is applied to the public event page\n2. Verify that theme customizations are correctly applied as CSS custom properties\n3. Test theme application with each of the 7 themes\n4. Test light and dark mode variations\n5. Verify that theme switching works correctly\n6. Test that the theme CSS is loaded correctly\n7. Measure performance impact of theme application\n8. Test accessibility of themed pages with screen readers and keyboard navigation",
      "priority": "high",
      "dependencies": [
        1,
        2,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Theme Selection UI Component",
      "description": "Create a theme picker component that displays visual thumbnails for each theme and allows single-click selection.",
      "details": "Implement a ThemePickerComponent that displays visual thumbnails for each of the 7 themes and allows users to select a theme with a single click. This component should be integrated into both event creation and edit forms.\n\n1. Create a LiveComponent for the theme picker:\n```elixir\ndefmodule EventasaurusAppWeb.ThemePickerComponent do\n  use EventasaurusAppWeb, :live_component\n  alias EventasaurusApp.Themes\n  \n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    <div class=\"theme-picker\">\n      <h3>Choose a theme</h3>\n      <div class=\"theme-options\">\n        <%= for theme <- available_themes() do %>\n          <div class={[\"theme-option\", @selected_theme == theme && \"selected\"]} \n               phx-click=\"select-theme\" \n               phx-value-theme={theme} \n               phx-target={@myself}>\n            <div class={[\"theme-thumbnail\", \"theme-#{theme}\"]}>\n              <!-- Theme preview thumbnail -->\n              <div class=\"thumbnail-header\"></div>\n              <div class=\"thumbnail-content\"></div>\n              <div class=\"thumbnail-button\"></div>\n            </div>\n            <div class=\"theme-name\"><%= theme_display_name(theme) %></div>\n          </div>\n        <% end %>\n      </div>\n    </div>\n    \"\"\"\n  end\n  \n  @impl true\n  def handle_event(\"select-theme\", %{\"theme\" => theme_string}, socket) do\n    theme = String.to_existing_atom(theme_string)\n    \n    if Themes.valid_theme?(theme) do\n      send(self(), {:theme_selected, theme})\n      {:noreply, assign(socket, selected_theme: theme)}\n    else\n      {:noreply, socket}\n    end\n  end\n  \n  defp available_themes do\n    [:minimal, :cosmic, :velocity, :retro, :celebration, :nature, :professional]\n  end\n  \n  defp theme_display_name(:minimal), do: \"Minimal\"\n  defp theme_display_name(:cosmic), do: \"Cosmic\"\n  defp theme_display_name(:velocity), do: \"Velocity\"\n  defp theme_display_name(:retro), do: \"Retro\"\n  defp theme_display_name(:celebration), do: \"Celebration\"\n  defp theme_display_name(:nature), do: \"Nature\"\n  defp theme_display_name(:professional), do: \"Professional\"\nend\n```\n\n2. Add CSS for the theme picker component:\n```css\n.theme-picker {\n  margin-bottom: 2rem;\n}\n\n.theme-options {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));\n  gap: 1rem;\n  margin-top: 1rem;\n}\n\n.theme-option {\n  cursor: pointer;\n  text-align: center;\n  transition: transform 0.2s;\n}\n\n.theme-option:hover {\n  transform: translateY(-5px);\n}\n\n.theme-option.selected {\n  outline: 2px solid var(--theme-primary-color);\n  border-radius: 8px;\n}\n\n.theme-thumbnail {\n  height: 100px;\n  border-radius: 8px;\n  overflow: hidden;\n  margin-bottom: 0.5rem;\n  border: 1px solid #eaeaea;\n}\n\n/* Theme-specific thumbnail styles */\n.theme-thumbnail.theme-minimal {\n  background-color: white;\n}\n\n.theme-thumbnail.theme-cosmic {\n  background-color: #1a1a2e;\n  background-image: linear-gradient(to bottom right, #1a1a2e, #16213e);\n}\n\n/* Add styles for other theme thumbnails */\n\n.theme-name {\n  font-size: 14px;\n  font-weight: 500;\n}\n```\n\n3. Integrate the theme picker into the event form:\n```elixir\ndefmodule EventasaurusAppWeb.EventLive.FormComponent do\n  use EventasaurusAppWeb, :live_component\n  \n  # Existing code...\n  \n  @impl true\n  def update(%{event: event} = assigns, socket) do\n    changeset = Events.change_event(event)\n    \n    {:ok,\n     socket\n     |> assign(assigns)\n     |> assign(:changeset, changeset)\n     |> assign(:selected_theme, event.theme)}\n  end\n  \n  @impl true\n  def handle_info({:theme_selected, theme}, socket) do\n    # Update the event with the selected theme\n    {:ok, event} = Events.update_event_theme(socket.assigns.event, theme)\n    \n    {:noreply,\n     socket\n     |> assign(:event, event)\n     |> assign(:selected_theme, theme)\n     |> put_flash(:info, \"Theme updated successfully\")}\n  end\n  \n  # Existing code...\n  \n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    <div>\n      <!-- Existing form content... -->\n      \n      <section class=\"theme-section\">\n        <.live_component\n          module={EventasaurusAppWeb.ThemePickerComponent}\n          id=\"theme-picker\"\n          selected_theme={@selected_theme}\n        />\n      </section>\n      \n      <!-- Remaining form content... -->\n    </div>\n    \"\"\"\n  end\nend\n```",
      "testStrategy": "1. Test that all 7 themes are displayed in the theme picker\n2. Verify that clicking a theme correctly selects it\n3. Test that the selected theme is visually indicated\n4. Verify that theme selection is saved to the database\n5. Test the integration with event creation and edit forms\n6. Test the component's responsive behavior on different screen sizes\n7. Verify that theme thumbnails accurately represent the actual themes",
      "priority": "medium",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Theme Preview Functionality",
      "description": "Implement real-time preview capability for themes, allowing users to see how their event page will look with different themes.",
      "details": "Create a theme preview functionality that allows users to see a real-time preview of their event page with the selected theme before applying it. The preview should include key event page elements.\n\n1. Create a ThemePreviewComponent:\n```elixir\ndefmodule EventasaurusAppWeb.ThemePreviewComponent do\n  use EventasaurusAppWeb, :live_component\n  alias EventasaurusApp.Events\n  alias EventasaurusApp.Themes\n  \n  @impl true\n  def update(assigns, socket) do\n    theme_data = if assigns.preview_theme do\n      # For preview, merge default theme settings with current customizations\n      current_customizations = assigns.event.theme_customizations\n      Themes.merge_customizations(assigns.preview_theme, current_customizations)\n    else\n      Events.get_event_theme_data(assigns.event)\n    end\n    \n    theme_class = if assigns.preview_theme do\n      Themes.get_theme_css_class(assigns.preview_theme)\n    else\n      Themes.get_theme_css_class(assigns.event.theme)\n    end\n    \n    {:ok,\n     socket\n     |> assign(assigns)\n     |> assign(:theme_data, theme_data)\n     |> assign(:theme_class, theme_class)}\n  end\n  \n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    <div class=\"theme-preview-container\">\n      <div class=\"theme-preview-header\">\n        <h3>Theme Preview</h3>\n        <%= if @preview_theme do %>\n          <div class=\"preview-actions\">\n            <button phx-click=\"apply-theme\" phx-target={@myself} class=\"btn-primary\">Apply Theme</button>\n            <button phx-click=\"cancel-preview\" phx-target={@myself} class=\"btn-secondary\">Cancel</button>\n          </div>\n        <% end %>\n      </div>\n      \n      <div class={[\"theme-preview\", @theme_class]}>\n        <!-- Simplified event page preview -->\n        <div class=\"preview-event-header\">\n          <h1><%= @event.title %></h1>\n          <p class=\"preview-event-date\">Dec 15, 2023 • 7:00 PM</p>\n        </div>\n        \n        <div class=\"preview-event-description\">\n          <p><%= String.slice(@event.description || \"\", 0, 150) %><%= if String.length(@event.description || \"\") > 150, do: \"...\", else: \"\" %></p>\n        </div>\n        \n        <div class=\"preview-event-actions\">\n          <button class=\"preview-register-btn\">Register Now</button>\n        </div>\n      </div>\n      \n      <style>\n        .theme-preview {\n          --theme-primary-color: <%= @theme_data[\"colors\"][\"primary\"] %>;\n          --theme-secondary-color: <%= @theme_data[\"colors\"][\"secondary\"] %>;\n          --theme-accent-color: <%= @theme_data[\"colors\"][\"accent\"] %>;\n          --theme-background-color: <%= @theme_data[\"colors\"][\"background\"] %>;\n          --theme-text-color: <%= @theme_data[\"colors\"][\"text\"] %>;\n          \n          --theme-font-family: <%= @theme_data[\"typography\"][\"font_family\"] %>;\n          --theme-heading-weight: <%= @theme_data[\"typography\"][\"heading_weight\"] %>;\n          --theme-body-size: <%= @theme_data[\"typography\"][\"body_size\"] %>;\n          \n          --theme-border-radius: <%= @theme_data[\"layout\"][\"border_radius\"] %>;\n          /* Other custom properties... */\n        }\n      </style>\n    </div>\n    \"\"\"\n  end\n  \n  @impl true\n  def handle_event(\"apply-theme\", _, socket) do\n    # Apply the preview theme to the event\n    {:ok, event} = Events.update_event_theme(socket.assigns.event, socket.assigns.preview_theme)\n    \n    send(self(), {:theme_updated, event})\n    \n    {:noreply,\n     socket\n     |> assign(:event, event)\n     |> assign(:preview_theme, nil)}\n  end\n  \n  @impl true\n  def handle_event(\"cancel-preview\", _, socket) do\n    {:noreply, assign(socket, :preview_theme, nil)}\n  end\nend\n```\n\n2. Add CSS for the theme preview:\n```css\n.theme-preview-container {\n  margin-top: 2rem;\n  border: 1px solid #eaeaea;\n  border-radius: 8px;\n  overflow: hidden;\n}\n\n.theme-preview-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 1rem;\n  border-bottom: 1px solid #eaeaea;\n}\n\n.preview-actions {\n  display: flex;\n  gap: 0.5rem;\n}\n\n.theme-preview {\n  padding: 2rem;\n  min-height: 300px;\n  font-family: var(--theme-font-family);\n  font-size: var(--theme-body-size);\n  color: var(--theme-text-color);\n  background-color: var(--theme-background-color);\n}\n\n.preview-event-header h1 {\n  font-weight: var(--theme-heading-weight);\n  margin-bottom: 0.5rem;\n}\n\n.preview-event-date {\n  color: var(--theme-secondary-color);\n  margin-bottom: 1.5rem;\n}\n\n.preview-event-description {\n  margin-bottom: 2rem;\n}\n\n.preview-register-btn {\n  background-color: var(--theme-primary-color);\n  color: white;\n  padding: 0.75rem 1.5rem;\n  border-radius: var(--theme-border-radius);\n  font-weight: 500;\n  border: none;\n  cursor: pointer;\n}\n```\n\n3. Update the EventLive.FormComponent to include the preview functionality:\n```elixir\ndefmodule EventasaurusAppWeb.EventLive.FormComponent do\n  # Existing code...\n  \n  @impl true\n  def update(%{event: event} = assigns, socket) do\n    changeset = Events.change_event(event)\n    \n    {:ok,\n     socket\n     |> assign(assigns)\n     |> assign(:changeset, changeset)\n     |> assign(:selected_theme, event.theme)\n     |> assign(:preview_theme, nil)}\n  end\n  \n  @impl true\n  def handle_info({:theme_selected, theme}, socket) do\n    # Instead of immediately updating, set as preview\n    {:noreply, assign(socket, :preview_theme, theme)}\n  end\n  \n  @impl true\n  def handle_info({:theme_updated, event}, socket) do\n    {:noreply,\n     socket\n     |> assign(:event, event)\n     |> assign(:selected_theme, event.theme)\n     |> put_flash(:info, \"Theme updated successfully\")}\n  end\n  \n  # Existing code...\n  \n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    <div>\n      <!-- Existing form content... -->\n      \n      <section class=\"theme-section\">\n        <.live_component\n          module={EventasaurusAppWeb.ThemePickerComponent}\n          id=\"theme-picker\"\n          selected_theme={@selected_theme}\n        />\n        \n        <.live_component\n          module={EventasaurusAppWeb.ThemePreviewComponent}\n          id=\"theme-preview\"\n          event={@event}\n          preview_theme={@preview_theme}\n        />\n      </section>\n      \n      <!-- Remaining form content... -->\n    </div>\n    \"\"\"\n  end\nend\n```",
      "testStrategy": "1. Test that the preview correctly displays the selected theme\n2. Verify that the preview includes key event page elements\n3. Test that applying a previewed theme updates the event\n4. Test that canceling a preview reverts to the current theme\n5. Verify that the preview accurately represents how the public page will look\n6. Test the preview with all 7 themes\n7. Test the preview with various event data (long titles, descriptions, etc.)",
      "priority": "medium",
      "dependencies": [
        4,
        5
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Theme Customization Interface",
      "description": "Build a comprehensive theme customization interface that allows users to customize colors, typography, and layout options.",
      "details": "Implement a theme customization interface that allows users to customize colors, typography, and layout options for their selected theme. The interface should provide color pickers, font selectors, and layout option controls.\n\n1. Create a ThemeCustomizationComponent:\n```elixir\ndefmodule EventasaurusAppWeb.ThemeCustomizationComponent do\n  use EventasaurusAppWeb, :live_component\n  alias EventasaurusApp.Events\n  alias EventasaurusApp.Themes\n  \n  @impl true\n  def update(assigns, socket) do\n    theme_data = Events.get_event_theme_data(assigns.event)\n    \n    {:ok,\n     socket\n     |> assign(assigns)\n     |> assign(:theme_data, theme_data)\n     |> assign(:active_tab, :colors)}\n  end\n  \n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    <div class=\"theme-customization\">\n      <h3>Customize Theme</h3>\n      \n      <div class=\"customization-tabs\">\n        <button class={[\"tab\", @active_tab == :colors && \"active\"]} \n                phx-click=\"switch-tab\" \n                phx-value-tab=\"colors\" \n                phx-target={@myself}>Colors</button>\n        <button class={[\"tab\", @active_tab == :typography && \"active\"]} \n                phx-click=\"switch-tab\" \n                phx-value-tab=\"typography\" \n                phx-target={@myself}>Typography</button>\n        <button class={[\"tab\", @active_tab == :layout && \"active\"]} \n                phx-click=\"switch-tab\" \n                phx-value-tab=\"layout\" \n                phx-target={@myself}>Layout</button>\n      </div>\n      \n      <div class=\"customization-content\">\n        <%= if @active_tab == :colors do %>\n          <div class=\"color-customization\">\n            <div class=\"color-option\">\n              <label>Primary Color</label>\n              <input type=\"color\" \n                     value={@theme_data[\"colors\"][\"primary\"]} \n                     phx-change=\"update-color\" \n                     phx-value-color=\"primary\" \n                     phx-target={@myself} />\n            </div>\n            \n            <div class=\"color-option\">\n              <label>Secondary Color</label>\n              <input type=\"color\" \n                     value={@theme_data[\"colors\"][\"secondary\"]} \n                     phx-change=\"update-color\" \n                     phx-value-color=\"secondary\" \n                     phx-target={@myself} />\n            </div>\n            \n            <div class=\"color-option\">\n              <label>Accent Color</label>\n              <input type=\"color\" \n                     value={@theme_data[\"colors\"][\"accent\"]} \n                     phx-change=\"update-color\" \n                     phx-value-color=\"accent\" \n                     phx-target={@myself} />\n            </div>\n            \n            <div class=\"color-option\">\n              <label>Background Color</label>\n              <input type=\"color\" \n                     value={@theme_data[\"colors\"][\"background\"]} \n                     phx-change=\"update-color\" \n                     phx-value-color=\"background\" \n                     phx-target={@myself} />\n            </div>\n            \n            <div class=\"color-option\">\n              <label>Text Color</label>\n              <input type=\"color\" \n                     value={@theme_data[\"colors\"][\"text\"]} \n                     phx-change=\"update-color\" \n                     phx-value-color=\"text\" \n                     phx-target={@myself} />\n            </div>\n            \n            <div class=\"color-presets\">\n              <h4>Color Presets</h4>\n              <div class=\"preset-options\">\n                <%= for {name, preset} <- color_presets(@event.theme) do %>\n                  <button class=\"preset-option\" \n                          phx-click=\"apply-color-preset\" \n                          phx-value-preset={name} \n                          phx-target={@myself}>\n                    <div class=\"preset-preview\" style={\"background: linear-gradient(to right, #{preset.primary}, #{preset.accent})\"}></div>\n                    <span><%= name %></span>\n                  </button>\n                <% end %>\n              </div>\n            </div>\n          </div>\n        <% end %>\n        \n        <%= if @active_tab == :typography do %>\n          <div class=\"typography-customization\">\n            <div class=\"font-option\">\n              <label>Font Family</label>\n              <select phx-change=\"update-typography\" \n                      phx-value-property=\"font_family\" \n                      phx-target={@myself}>\n                <%= for font <- available_fonts() do %>\n                  <option value={font} selected={font == @theme_data[\"typography\"][\"font_family\"]}>\n                    <%= font %>\n                  </option>\n                <% end %>\n              </select>\n            </div>\n            \n            <div class=\"font-option\">\n              <label>Heading Weight</label>\n              <select phx-change=\"update-typography\" \n                      phx-value-property=\"heading_weight\" \n                      phx-target={@myself}>\n                <%= for weight <- [\"400\", \"500\", \"600\", \"700\"] do %>\n                  <option value={weight} selected={weight == @theme_data[\"typography\"][\"heading_weight\"]}>\n                    <%= weight %>\n                  </option>\n                <% end %>\n              </select>\n            </div>\n            \n            <div class=\"font-option\">\n              <label>Body Text Size</label>\n              <select phx-change=\"update-typography\" \n                      phx-value-property=\"body_size\" \n                      phx-target={@myself}>\n                <%= for size <- [\"14px\", \"16px\", \"18px\"] do %>\n                  <option value={size} selected={size == @theme_data[\"typography\"][\"body_size\"]}>\n                    <%= size %>\n                  </option>\n                <% end %>\n              </select>\n            </div>\n          </div>\n        <% end %>\n        \n        <%= if @active_tab == :layout do %>\n          <div class=\"layout-customization\">\n            <div class=\"layout-option\">\n              <label>Border Radius</label>\n              <select phx-change=\"update-layout\" \n                      phx-value-property=\"border_radius\" \n                      phx-target={@myself}>\n                <%= for {name, value} <- border_radius_options() do %>\n                  <option value={value} selected={value == @theme_data[\"layout\"][\"border_radius\"]}>\n                    <%= name %>\n                  </option>\n                <% end %>\n              </select>\n            </div>\n            \n            <div class=\"layout-option\">\n              <label>Shadow Style</label>\n              <select phx-change=\"update-layout\" \n                      phx-value-property=\"shadow_style\" \n                      phx-target={@myself}>\n                <%= for style <- [\"none\", \"soft\", \"pronounced\"] do %>\n                  <option value={style} selected={style == @theme_data[\"layout\"][\"shadow_style\"]}>\n                    <%= String.capitalize(style) %>\n                  </option>\n                <% end %>\n              </select>\n            </div>\n            \n            <div class=\"layout-option\">\n              <label>Mode</label>\n              <div class=\"mode-toggle\">\n                <button class={[\"mode-option\", @theme_data[\"mode\"] == \"light\" && \"active\"]} \n                        phx-click=\"update-mode\" \n                        phx-value-mode=\"light\" \n                        phx-target={@myself}>Light</button>\n                <button class={[\"mode-option\", @theme_data[\"mode\"] == \"dark\" && \"active\"]} \n                        phx-click=\"update-mode\" \n                        phx-value-mode=\"dark\" \n                        phx-target={@myself}>Dark</button>\n              </div>\n            </div>\n          </div>\n        <% end %>\n        \n        <div class=\"customization-actions\">\n          <button phx-click=\"reset-customizations\" phx-target={@myself} class=\"btn-secondary\">Reset to Default</button>\n        </div>\n      </div>\n    </div>\n    \"\"\"\n  end\n  \n  @impl true\n  def handle_event(\"switch-tab\", %{\"tab\" => tab}, socket) do\n    {:noreply, assign(socket, :active_tab, String.to_existing_atom(tab))}\n  end\n  \n  @impl true\n  def handle_event(\"update-color\", %{\"color\" => color, \"value\" => value}, socket) do\n    updated_theme_data = update_in(socket.assigns.theme_data, [\"colors\", color], fn _ -> value end)\n    save_theme_customizations(socket, updated_theme_data)\n  end\n  \n  @impl true\n  def handle_event(\"update-typography\", %{\"property\" => property, \"value\" => value}, socket) do\n    updated_theme_data = update_in(socket.assigns.theme_data, [\"typography\", property], fn _ -> value end)\n    save_theme_customizations(socket, updated_theme_data)\n  end\n  \n  @impl true\n  def handle_event(\"update-layout\", %{\"property\" => property, \"value\" => value}, socket) do\n    updated_theme_data = update_in(socket.assigns.theme_data, [\"layout\", property], fn _ -> value end)\n    save_theme_customizations(socket, updated_theme_data)\n  end\n  \n  @impl true\n  def handle_event(\"update-mode\", %{\"mode\" => mode}, socket) do\n    updated_theme_data = Map.put(socket.assigns.theme_data, \"mode\", mode)\n    save_theme_customizations(socket, updated_theme_data)\n  end\n  \n  @impl true\n  def handle_event(\"apply-color-preset\", %{\"preset\" => preset_name}, socket) do\n    preset = Enum.find(color_presets(socket.assigns.event.theme), fn {name, _} -> name == preset_name end)\n    \n    if preset do\n      {_, colors} = preset\n      updated_theme_data = update_in(socket.assigns.theme_data, [\"colors\"], fn _ -> \n        %{\n          \"primary\" => colors.primary,\n          \"secondary\" => colors.secondary,\n          \"accent\" => colors.accent,\n          \"background\" => colors.background,\n          \"text\" => colors.text\n        }\n      end)\n      \n      save_theme_customizations(socket, updated_theme_data)\n    else\n      {:noreply, socket}\n    end\n  end\n  \n  @impl true\n  def handle_event(\"reset-customizations\", _, socket) do\n    default_customizations = Themes.get_default_customizations(socket.assigns.event.theme)\n    \n    {:ok, event} = Events.update_event_theme_customizations(socket.assigns.event, default_customizations)\n    \n    send(self(), {:theme_customizations_updated, event})\n    \n    {:noreply,\n     socket\n     |> assign(:event, event)\n     |> assign(:theme_data, default_customizations)}\n  end\n  \n  defp save_theme_customizations(socket, updated_theme_data) do\n    case Events.update_event_theme_customizations(socket.assigns.event, updated_theme_data) do\n      {:ok, event} ->\n        send(self(), {:theme_customizations_updated, event})\n        \n        {:noreply,\n         socket\n         |> assign(:event, event)\n         |> assign(:theme_data, updated_theme_data)}\n      \n      {:error, _reason} ->\n        {:noreply, socket}\n    end\n  end\n  \n  defp available_fonts do\n    [\"Inter\", \"Playfair Display\", \"Roboto\", \"Open Sans\", \"Montserrat\", \"Lato\"]\n  end\n  \n  defp border_radius_options do\n    [\n      {\"Sharp\", \"0px\"},\n      {\"Rounded\", \"4px\"},\n      {\"Very Rounded\", \"8px\"}\n    ]\n  end\n  \n  defp color_presets(:minimal) do\n    [\n      {\"Default\", %{\n        primary: \"#000000\",\n        secondary: \"#333333\",\n        accent: \"#0066cc\",\n        background: \"#ffffff\",\n        text: \"#000000\"\n      }},\n      {\"Blue\", %{\n        primary: \"#0066cc\",\n        secondary: \"#333333\",\n        accent: \"#3399ff\",\n        background: \"#ffffff\",\n        text: \"#000000\"\n      }},\n      # Add more presets\n    ]\n  end\n  \n  # Add color presets for other themes\n  defp color_presets(_), do: color_presets(:minimal)\nend\n```\n\n2. Add CSS for the customization component:\n```css\n.theme-customization {\n  margin-top: 2rem;\n  border: 1px solid #eaeaea;\n  border-radius: 8px;\n  overflow: hidden;\n}\n\n.customization-tabs {\n  display: flex;\n  border-bottom: 1px solid #eaeaea;\n}\n\n.customization-tabs .tab {\n  padding: 1rem;\n  background: none;\n  border: none;\n  cursor: pointer;\n  font-weight: 500;\n  color: #666;\n}\n\n.customization-tabs .tab.active {\n  color: #000;\n  border-bottom: 2px solid #000;\n}\n\n.customization-content {\n  padding: 1.5rem;\n}\n\n.color-option, .font-option, .layout-option {\n  margin-bottom: 1rem;\n}\n\n.color-option label, .font-option label, .layout-option label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 500;\n}\n\n.color-option input[type=\"color\"] {\n  width: 100%;\n  height: 40px;\n  border: 1px solid #eaeaea;\n  border-radius: 4px;\n}\n\n.font-option select, .layout-option select {\n  width: 100%;\n  padding: 0.5rem;\n  border: 1px solid #eaeaea;\n  border-radius: 4px;\n}\n\n.color-presets {\n  margin-top: 2rem;\n}\n\n.preset-options {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));\n  gap: 1rem;\n  margin-top: 0.5rem;\n}\n\n.preset-option {\n  background: none;\n  border: none;\n  cursor: pointer;\n  text-align: center;\n}\n\n.preset-preview {\n  height: 40px;\n  border-radius: 4px;\n  margin-bottom: 0.5rem;\n}\n\n.mode-toggle {\n  display: flex;\n  border: 1px solid #eaeaea;\n  border-radius: 4px;\n  overflow: hidden;\n}\n\n.mode-option {\n  flex: 1;\n  padding: 0.5rem;\n  background: none;\n  border: none;\n  cursor: pointer;\n}\n\n.mode-option.active {\n  background-color: #f5f5f5;\n  font-weight: 500;\n}\n\n.customization-actions {\n  margin-top: 2rem;\n  text-align: right;\n}\n```\n\n3. Update the EventLive.FormComponent to include the customization component:\n```elixir\ndefmodule EventasaurusAppWeb.EventLive.FormComponent do\n  # Existing code...\n  \n  @impl true\n  def handle_info({:theme_customizations_updated, event}, socket) do\n    {:noreply,\n     socket\n     |> assign(:event, event)\n     |> put_flash(:info, \"Theme customizations updated\")}\n  end\n  \n  # Existing code...\n  \n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    <div>\n      <!-- Existing form content... -->\n      \n      <section class=\"theme-section\">\n        <.live_component\n          module={EventasaurusAppWeb.ThemePickerComponent}\n          id=\"theme-picker\"\n          selected_theme={@selected_theme}\n        />\n        \n        <.live_component\n          module={EventasaurusAppWeb.ThemePreviewComponent}\n          id=\"theme-preview\"\n          event={@event}\n          preview_theme={@preview_theme}\n        />\n        \n        <.live_component\n          module={EventasaurusAppWeb.ThemeCustomizationComponent}\n          id=\"theme-customization\"\n          event={@event}\n        />\n      </section>\n      \n      <!-- Remaining form content... -->\n    </div>\n    \"\"\"\n  end\nend\n```",
      "testStrategy": "1. Test that all customization options are displayed correctly\n2. Verify that color pickers update the theme colors in real-time\n3. Test that typography options correctly change fonts and sizes\n4. Verify that layout options update border radius and shadow styles\n5. Test that light/dark mode toggle works correctly\n6. Verify that color presets apply correctly\n7. Test that reset functionality restores default theme settings\n8. Verify that customizations are saved to the database\n9. Test accessibility of the customization interface\n10. Test color contrast validation for accessibility",
      "priority": "medium",
      "dependencies": [
        2,
        6
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Theme Data Persistence and Management",
      "description": "Implement theme data persistence, automatic saving, and theme management functionality.",
      "details": "Implement the functionality to persist theme selections and customizations, automatically save changes, and provide theme management capabilities such as copying themes between events.\n\n1. Update the Events context with theme management functions:\n```elixir\ndefmodule EventasaurusApp.Events do\n  # Existing code...\n  \n  @doc \"\"\"\n  Updates an event's theme with debounced saving.\n  \"\"\"\n  def update_event_theme_debounced(event, theme) do\n    # Use a GenServer or similar to debounce saves\n    EventasaurusApp.ThemeSaver.save_theme(event.id, %{theme: theme})\n    {:ok, %{event | theme: theme}}\n  end\n  \n  @doc \"\"\"\n  Updates an event's theme customizations with debounced saving.\n  \"\"\"\n  def update_event_theme_customizations_debounced(event, customizations) do\n    case Themes.validate_customizations(customizations) do\n      {:ok, valid_customizations} ->\n        EventasaurusApp.ThemeSaver.save_theme(event.id, %{theme_customizations: valid_customizations})\n        {:ok, %{event | theme_customizations: valid_customizations}}\n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n  \n  @doc \"\"\"\n  Copies theme settings from one event to another.\n  \"\"\"\n  def copy_event_theme(source_event_id, target_event_id) do\n    with %Event{} = source_event <- get_event(source_event_id),\n         %Event{} = target_event <- get_event(target_event_id) do\n      \n      target_event\n      |> Event.changeset(%{\n        theme: source_event.theme,\n        theme_customizations: source_event.theme_customizations\n      })\n      |> Repo.update()\n    else\n      nil -> {:error, \"Event not found\"}\n    end\n  end\n  \n  @doc \"\"\"\n  Gets all events for an organizer with their themes.\n  \"\"\"\n  def list_events_with_themes(organizer_id) do\n    Event\n    |> where([e], e.organizer_id == ^organizer_id)\n    |> select([e], %{id: e.id, title: e.title, theme: e.theme})\n    |> Repo.all()\n  end\nend\n```\n\n2. Create a ThemeSaver GenServer for debounced saving:\n```elixir\ndefmodule EventasaurusApp.ThemeSaver do\n  @moduledoc \"\"\"\n  GenServer for debounced saving of theme changes.\n  \"\"\"\n  use GenServer\n  alias EventasaurusApp.Events.Event\n  alias EventasaurusApp.Repo\n  \n  # Client API\n  \n  def start_link(_) do\n    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)\n  end\n  \n  def save_theme(event_id, attrs) do\n    GenServer.cast(__MODULE__, {:save_theme, event_id, attrs})\n  end\n  \n  # Server Callbacks\n  \n  @impl true\n  def init(state) do\n    {:ok, state}\n  end\n  \n  @impl true\n  def handle_cast({:save_theme, event_id, attrs}, state) do\n    # Cancel any existing timer for this event\n    if Map.has_key?(state, event_id) do\n      Process.cancel_timer(state[event_id])\n    end\n    \n    # Set a new timer to save after 500ms\n    timer = Process.send_after(self(), {:do_save, event_id, attrs}, 500)\n    \n    {:noreply, Map.put(state, event_id, timer)}\n  end\n  \n  @impl true\n  def handle_info({:do_save, event_id, attrs}, state) do\n    # Actually save the theme changes\n    event = Repo.get(Event, event_id)\n    \n    if event do\n      event\n      |> Event.changeset(attrs)\n      |> Repo.update()\n    end\n    \n    {:noreply, Map.delete(state, event_id)}\n  end\nend\n```\n\n3. Add the ThemeSaver to your application supervision tree:\n```elixir\ndefmodule EventasaurusApp.Application do\n  # Existing code...\n  \n  def start(_type, _args) do\n    children = [\n      # Existing children...\n      EventasaurusApp.ThemeSaver\n    ]\n    \n    # Existing code...\n  end\nend\n```\n\n4. Create a ThemeCopyComponent for copying themes between events:\n```elixir\ndefmodule EventasaurusAppWeb.ThemeCopyComponent do\n  use EventasaurusAppWeb, :live_component\n  alias EventasaurusApp.Events\n  \n  @impl true\n  def update(assigns, socket) do\n    events = Events.list_events_with_themes(assigns.current_user.id)\n    \n    {:ok,\n     socket\n     |> assign(assigns)\n     |> assign(:events, events)\n     |> assign(:selected_event_id, nil)}\n  end\n  \n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    <div class=\"theme-copy\">\n      <h3>Copy Theme From Another Event</h3>\n      \n      <div class=\"event-selector\">\n        <label>Select Source Event</label>\n        <select phx-change=\"select-event\" phx-target={@myself}>\n          <option value=\"\">Choose an event...</option>\n          <%= for event <- @events do %>\n            <%= if event.id != @event.id do %>\n              <option value={event.id}><%= event.title %></option>\n            <% end %>\n          <% end %>\n        </select>\n      </div>\n      \n      <div class=\"copy-actions\">\n        <button class=\"btn-primary\" \n                phx-click=\"copy-theme\" \n                phx-target={@myself} \n                disabled={is_nil(@selected_event_id)}>Copy Theme</button>\n      </div>\n    </div>\n    \"\"\"\n  end\n  \n  @impl true\n  def handle_event(\"select-event\", %{\"value\" => \"\"}, socket) do\n    {:noreply, assign(socket, :selected_event_id, nil)}\n  end\n  \n  @impl true\n  def handle_event(\"select-event\", %{\"value\" => event_id}, socket) do\n    {:noreply, assign(socket, :selected_event_id, String.to_integer(event_id))}\n  end\n  \n  @impl true\n  def handle_event(\"copy-theme\", _, %{assigns: %{selected_event_id: nil}} = socket) do\n    {:noreply, socket}\n  end\n  \n  @impl true\n  def handle_event(\"copy-theme\", _, socket) do\n    case Events.copy_event_theme(socket.assigns.selected_event_id, socket.assigns.event.id) do\n      {:ok, updated_event} ->\n        send(self(), {:theme_updated, updated_event})\n        \n        {:noreply,\n         socket\n         |> assign(:event, updated_event)\n         |> assign(:selected_event_id, nil)}\n      \n      {:error, _reason} ->\n        {:noreply,\n         socket\n         |> put_flash(:error, \"Failed to copy theme\")}\n    end\n  end\nend\n```\n\n5. Add CSS for the theme copy component:\n```css\n.theme-copy {\n  margin-top: 2rem;\n  padding: 1.5rem;\n  border: 1px solid #eaeaea;\n  border-radius: 8px;\n}\n\n.event-selector {\n  margin-bottom: 1.5rem;\n}\n\n.event-selector label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 500;\n}\n\n.event-selector select {\n  width: 100%;\n  padding: 0.5rem;\n  border: 1px solid #eaeaea;\n  border-radius: 4px;\n}\n```\n\n6. Update the EventLive.FormComponent to include the theme copy component:\n```elixir\ndefmodule EventasaurusAppWeb.EventLive.FormComponent do\n  # Existing code...\n  \n  @impl true\n  def render(assigns) do\n    ~H\"\"\"\n    <div>\n      <!-- Existing form content... -->\n      \n      <section class=\"theme-section\">\n        <!-- Existing theme components... -->\n        \n        <.live_component\n          module={EventasaurusAppWeb.ThemeCopyComponent}\n          id=\"theme-copy\"\n          event={@event}\n          current_user={@current_user}\n        />\n      </section>\n      \n      <!-- Remaining form content... -->\n    </div>\n    \"\"\"\n  end\nend\n```",
      "testStrategy": "1. Test that theme changes are saved automatically with debouncing\n2. Verify that theme customizations are persisted correctly\n3. Test the theme copying functionality between events\n4. Verify that validation works for theme data\n5. Test error handling for invalid theme data\n6. Verify that the ThemeSaver GenServer correctly debounces saves\n7. Test that theme data integrity is maintained during event updates\n8. Verify that the theme copy component correctly lists available events\n9. Test performance of theme data persistence operations",
      "priority": "medium",
      "dependencies": [
        1,
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Accessibility and Performance Optimization",
      "description": "Ensure all themes meet accessibility standards and optimize performance for theme switching and loading.",
      "details": "Implement accessibility checks and performance optimizations for the theming system to ensure all themes meet WCAG 2.1 AA standards and have minimal performance impact.\n\n1. Create an accessibility validation module:\n```elixir\ndefmodule EventasaurusApp.Themes.AccessibilityValidator do\n  @moduledoc \"\"\"\n  Validates theme customizations for accessibility compliance.\n  \"\"\"\n  \n  @doc \"\"\"\n  Validates color contrast for accessibility.\n  Returns :ok if contrast is sufficient, or {:error, reason} if not.\n  \"\"\"\n  def validate_color_contrast(foreground, background) do\n    contrast_ratio = calculate_contrast_ratio(foreground, background)\n    \n    if contrast_ratio >= 4.5 do\n      :ok\n    else\n      {:error, \"Contrast ratio #{Float.round(contrast_ratio, 2)} is below WCAG AA minimum of 4.5\"}\n    end\n  end\n  \n  @doc \"\"\"\n  Validates a complete theme for accessibility issues.\n  \"\"\"\n  def validate_theme(theme_data) do\n    with :ok <- validate_text_contrast(theme_data),\n         :ok <- validate_button_contrast(theme_data) do\n      :ok\n    end\n  end\n  \n  defp validate_text_contrast(theme_data) do\n    text_color = theme_data[\"colors\"][\"text\"]\n    background_color = theme_data[\"colors\"][\"background\"]\n    \n    validate_color_contrast(text_color, background_color)\n  end\n  \n  defp validate_button_contrast(theme_data) do\n    primary_color = theme_data[\"colors\"][\"primary\"]\n    button_text_color = \"#FFFFFF\" # Assuming white text on buttons\n    \n    validate_color_contrast(button_text_color, primary_color)\n  end\n  \n  # Calculate contrast ratio between two colors\n  # Based on WCAG 2.1 formula: https://www.w3.org/TR/WCAG21/#contrast-minimum\n  defp calculate_contrast_ratio(color1, color2) do\n    l1 = relative_luminance(color1)\n    l2 = relative_luminance(color2)\n    \n    # Ensure lighter color is l1\n    {l1, l2} = if l1 > l2, do: {l1, l2}, else: {l2, l1}\n    \n    (l1 + 0.05) / (l2 + 0.05)\n  end\n  \n  # Calculate relative luminance of a color\n  # Based on WCAG 2.1 formula: https://www.w3.org/TR/WCAG21/#dfn-relative-luminance\n  defp relative_luminance(hex_color) do\n    {r, g, b} = hex_to_rgb(hex_color)\n    \n    r_srgb = r / 255\n    g_srgb = g / 255\n    b_srgb = b / 255\n    \n    r_linear = if r_srgb <= 0.03928, do: r_srgb / 12.92, else: :math.pow((r_srgb + 0.055) / 1.055, 2.4)\n    g_linear = if g_srgb <= 0.03928, do: g_srgb / 12.92, else: :math.pow((g_srgb + 0.055) / 1.055, 2.4)\n    b_linear = if b_srgb <= 0.03928, do: b_srgb / 12.92, else: :math.pow((b_srgb + 0.055) / 1.055, 2.4)\n    \n    0.2126 * r_linear + 0.7152 * g_linear + 0.0722 * b_linear\n  end\n  \n  # Convert hex color to RGB values\n  defp hex_to_rgb(hex) do\n    hex = String.replace_leading(hex, \"#\", \"\")\n    \n    {r, g, b} = case String.length(hex) do\n      3 -> # #RGB format\n        r = String.slice(hex, 0, 1)\n        g = String.slice(hex, 1, 1)\n        b = String.slice(hex, 2, 1)\n        {r <> r, g <> g, b <> b}\n      6 -> # #RRGGBB format\n        r = String.slice(hex, 0, 2)\n        g = String.slice(hex, 2, 2)\n        b = String.slice(hex, 4, 2)\n        {r, g, b}\n    end\n    \n    {String.to_integer(r, 16), String.to_integer(g, 16), String.to_integer(b, 16)}\n  end\nend\n```\n\n2. Update the Themes context to use the accessibility validator:\n```elixir\ndefmodule EventasaurusApp.Themes do\n  # Existing code...\n  \n  alias EventasaurusApp.Themes.AccessibilityValidator\n  \n  @doc \"\"\"\n  Validates theme customizations for proper structure and accessibility.\n  \"\"\"\n  def validate_customizations(customizations) do\n    # First validate structure\n    with {:ok, valid_customizations} <- validate_customization_structure(customizations),\n         # Then validate accessibility\n         :ok <- AccessibilityValidator.validate_theme(valid_customizations) do\n      {:ok, valid_customizations}\n    end\n  end\n  \n  defp validate_customization_structure(customizations) do\n    # Implement validation logic for customization structure\n    # Check required keys, value types, etc.\n    {:ok, customizations}\n  end\nend\n```\n\n3. Implement performance optimizations for theme CSS loading:\n```elixir\ndefmodule EventasaurusAppWeb.ThemeOptimizer do\n  @moduledoc \"\"\"\n  Optimizes theme loading and application for performance.\n  \"\"\"\n  \n  @doc \"\"\"\n  Returns optimized CSS for a theme with only the necessary styles.\n  \"\"\"\n  def get_optimized_theme_css(theme) do\n    # In a real implementation, this could:\n    # 1. Use a CDN for theme assets\n    # 2. Generate minimal CSS with only the required properties\n    # 3. Cache theme CSS for reuse\n    \"assets/css/themes/#{theme}.css\"\n  end\n  \n  @doc \"\"\"\n  Preloads theme assets for faster switching.\n  \"\"\"\n  def preload_theme_assets(conn, themes) do\n    # Generate preload link tags for theme assets\n    preload_links = for theme <- themes do\n      \"<link rel=\\\"preload\\\" href=\\\"/#{get_optimized_theme_css(theme)}\\\" as=\\\"style\\\">\"\n    end\n    \n    # Add preload links to response headers\n    Plug.Conn.put_resp_header(conn, \"Link\", Enum.join(preload_links, \", \"))\n  end\nend\n```\n\n4. Add performance monitoring for theme switching:\n```elixir\ndefmodule EventasaurusAppWeb.ThemePerformanceMonitor do\n  @moduledoc \"\"\"\n  Monitors and logs theme performance metrics.\n  \"\"\"\n  \n  require Logger\n  \n  @doc \"\"\"\n  Logs theme switching performance.\n  \"\"\"\n  def log_theme_switch(from_theme, to_theme, duration_ms) do\n    Logger.info(\"Theme switch: #{from_theme} -> #{to_theme} in #{duration_ms}ms\")\n    \n    # In a real implementation, this could send metrics to a monitoring service\n    if duration_ms > 100 do\n      Logger.warn(\"Theme switch exceeded performance target: #{duration_ms}ms\")\n    end\n  end\n  \n  @doc \"\"\"\n  Measures theme loading performance.\n  \"\"\"\n  def measure_theme_load(theme, fun) do\n    start_time = System.monotonic_time(:millisecond)\n    result = fun.()\n    end_time = System.monotonic_time(:millisecond)\n    \n    duration_ms = end_time - start_time\n    Logger.info(\"Theme load: #{theme} in #{duration_ms}ms\")\n    \n    {result, duration_ms}\n  end\nend\n```\n\n5. Update the public event page to include accessibility features:\n```heex\n<div class={[\"event-page\", @theme_class]} role=\"main\" aria-label=\"Event details\">\n  <header class=\"event-header\">\n    <h1 id=\"event-title\"><%= @event.title %></h1>\n    <p class=\"event-date\" aria-labelledby=\"event-title\">Dec 15, 2023 • 7:00 PM</p>\n  </header>\n  \n  <section class=\"event-description\" aria-label=\"Event description\">\n    <%= @event.description %>\n  </section>\n  \n  <section class=\"event-registration\" aria-label=\"Registration\">\n    <button class=\"register-btn\" aria-label=\"Register for event\">Register Now</button>\n  </section>\n  \n  <!-- Add keyboard navigation support -->\n  <script>\n    document.addEventListener('DOMContentLoaded', function() {\n      // Add keyboard navigation support\n      const focusableElements = document.querySelectorAll('button, a, input, select, textarea, [tabindex]:not([tabindex=\"-1\"])');\n      \n      // Ensure proper tab order\n      Array.from(focusableElements).forEach(function(element) {\n        element.addEventListener('keydown', function(e) {\n          if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n            element.click();\n          }\n        });\n      });\n    });\n  </script>\n</div>\n```\n\n6. Optimize CSS loading in the layout:\n```elixir\ndefmodule EventasaurusAppWeb.Layouts do\n  use EventasaurusAppWeb, :html\n  \n  # Existing code...\n  \n  def public_event(assigns) do\n    ~H\"\"\"\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <!-- Existing head content... -->\n        <link rel=\"stylesheet\" href={~p\"/assets/css/public.css\"} />\n        <link rel=\"stylesheet\" href={~p\"/assets/css/themes/base.css\"} />\n        \n        <!-- Optimized theme CSS loading -->\n        <link rel=\"stylesheet\" href={~p\"/assets/css/themes/#{@theme}.css\"} />\n        \n        <!-- Preload other common themes for faster switching -->\n        <link rel=\"preload\" href={~p\"/assets/css/themes/minimal.css\"} as=\"style\" />\n        \n        <!-- Add meta tags for accessibility -->\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n      </head>\n      <body>\n        <%= @inner_content %>\n        \n        <!-- Defer non-critical JavaScript -->\n        <script defer src={~p\"/assets/js/app.js\"}></script>\n      </body>\n    </html>\n    \"\"\"\n  end\nend\n```",
      "testStrategy": "1. Test all themes against WCAG 2.1 AA standards using automated tools\n2. Verify color contrast validation works correctly for various color combinations\n3. Test screen reader compatibility for all themes\n4. Verify keyboard navigation works correctly across all themes\n5. Measure theme switching performance and ensure it's under 100ms\n6. Test theme loading performance on various devices and network conditions\n7. Verify that CSS bundle size meets the requirements (<50KB total)\n8. Test performance with Chrome Lighthouse and ensure good scores\n9. Verify that accessibility validation prevents inaccessible color combinations\n10. Test with actual assistive technology devices",
      "priority": "high",
      "dependencies": [
        3,
        4,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Integration Testing and Documentation",
      "description": "Create comprehensive tests for the theming system and document the implementation for developers and users.",
      "details": "Implement comprehensive tests for the theming system and create documentation for both developers and users. This includes unit tests, integration tests, and end-to-end tests, as well as user guides and developer documentation.\n\n1. Create unit tests for the Themes context:\n```elixir\ndefmodule EventasaurusApp.ThemesTest do\n  use EventasaurusApp.DataCase\n  \n  alias EventasaurusApp.Themes\n  \n  describe \"theme validation\" do\n    test \"valid_theme?/1 returns true for valid themes\" do\n      assert Themes.valid_theme?(:minimal)\n      assert Themes.valid_theme?(:cosmic)\n      assert Themes.valid_theme?(:velocity)\n      assert Themes.valid_theme?(:retro)\n      assert Themes.valid_theme?(:celebration)\n      assert Themes.valid_theme?(:nature)\n      assert Themes.valid_theme?(:professional)\n    end\n    \n    test \"valid_theme?/1 returns false for invalid themes\" do\n      refute Themes.valid_theme?(:invalid_theme)\n      refute Themes.valid_theme?(\"minimal\")\n      refute Themes.valid_theme?(nil)\n    end\n  end\n  \n  describe \"theme customizations\" do\n    test \"merge_customizations/2 correctly merges with defaults\" do\n      theme = :minimal\n      customizations = %{\"colors\" => %{\"primary\" => \"#FF0000\"}}\n      \n      result = Themes.merge_customizations(theme, customizations)\n      \n      assert result[\"colors\"][\"primary\"] == \"#FF0000\"\n      assert result[\"colors\"][\"secondary\"] == Themes.get_default_customizations(theme)[\"colors\"][\"secondary\"]\n    end\n    \n    test \"validate_customizations/1 validates color contrast\" do\n      # Test with accessible colors\n      good_customizations = %{\n        \"colors\" => %{\n          \"text\" => \"#000000\",\n          \"background\" => \"#FFFFFF\"\n        }\n      }\n      \n      assert {:ok, _} = Themes.validate_customizations(good_customizations)\n      \n      # Test with inaccessible colors\n      bad_customizations = %{\n        \"colors\" => %{\n          \"text\" => \"#777777\",\n          \"background\" => \"#888888\"\n        }\n      }\n      \n      assert {:error, _} = Themes.validate_customizations(bad_customizations)\n    end\n  end\n  \n  describe \"theme CSS classes\" do\n    test \"get_theme_css_class/1 returns correct class name\" do\n      assert Themes.get_theme_css_class(:minimal) == \"theme-minimal\"\n      assert Themes.get_theme_css_class(:cosmic) == \"theme-cosmic\"\n    end\n    \n    test \"get_theme_css_class/1 returns default for invalid theme\" do\n      assert Themes.get_theme_css_class(:invalid) == \"theme-minimal\"\n    end\n  end\n  \n  describe \"default customizations\" do\n    test \"get_default_customizations/1 returns complete theme data\" do\n      result = Themes.get_default_customizations(:minimal)\n      \n      assert is_map(result)\n      assert is_map(result[\"colors\"])\n      assert is_map(result[\"typography\"])\n      assert is_map(result[\"layout\"])\n    end\n  end\nend\n```\n\n2. Create integration tests for theme application:\n```elixir\ndefmodule EventasaurusAppWeb.ThemeIntegrationTest do\n  use EventasaurusAppWeb.ConnCase\n  \n  import Phoenix.LiveViewTest\n  alias EventasaurusApp.Events\n  \n  setup do\n    # Create a test user and event\n    user = insert(:user)\n    event = insert(:event, organizer: user, theme: :minimal)\n    \n    %{user: user, event: event}\n  end\n  \n  describe \"theme application\" do\n    test \"public event page applies the correct theme\", %{event: event} do\n      {:ok, _view, html} = live(build_conn(), ~p\"/events/#{event.slug}\")\n      \n      assert html =~ \"theme-minimal\"\n    end\n    \n    test \"changing theme updates the event page\", %{user: user, event: event} do\n      # Log in as the event organizer\n      conn = log_in_user(build_conn(), user)\n      \n      # Navigate to event edit page\n      {:ok, view, _html} = live(conn, ~p\"/events/#{event.id}/edit\")\n      \n      # Select a different theme\n      view\n      |> element(\"[phx-target='#theme-picker'][phx-value-theme='cosmic']\")\n      |> render_click()\n      \n      # Apply the theme\n      view\n      |> element(\"button\", \"Apply Theme\")\n      |> render_click()\n      \n      # Verify the event was updated\n      updated_event = Events.get_event!(event.id)\n      assert updated_event.theme == :cosmic\n      \n      # Visit the public page and verify the theme is applied\n      {:ok, _view, html} = live(build_conn(), ~p\"/events/#{event.slug}\")\n      assert html =~ \"theme-cosmic\"\n    end\n  end\n  \n  describe \"theme customization\" do\n    test \"customizing colors updates the event\", %{user: user, event: event} do\n      # Log in as the event organizer\n      conn = log_in_user(build_conn(), user)\n      \n      # Navigate to event edit page\n      {:ok, view, _html} = live(conn, ~p\"/events/#{event.id}/edit\")\n      \n      # Update primary color\n      view\n      |> element(\"[phx-target='#theme-customization'][phx-value-color='primary']\")\n      |> render_change(%{value: \"#FF0000\"})\n      \n      # Verify the event was updated\n      updated_event = Events.get_event!(event.id)\n      assert updated_event.theme_customizations[\"colors\"][\"primary\"] == \"#FF0000\"\n    end\n  end\n  \n  describe \"theme performance\" do\n    test \"theme switching is fast\", %{user: user, event: event} do\n      # Log in as the event organizer\n      conn = log_in_user(build_conn(), user)\n      \n      # Navigate to event edit page\n      {:ok, view, _html} = live(conn, ~p\"/events/#{event.id}/edit\")\n      \n      # Measure time to switch theme\n      start_time = System.monotonic_time(:millisecond)\n      \n      view\n      |> element(\"[phx-target='#theme-picker'][phx-value-theme='cosmic']\")\n      |> render_click()\n      \n      view\n      |> element(\"button\", \"Apply Theme\")\n      |> render_click()\n      \n      end_time = System.monotonic_time(:millisecond)\n      duration = end_time - start_time\n      \n      # Theme switching should be under 100ms (adjust for test environment)\n      assert duration < 500\n    end\n  end\nend\n```\n\n3. Create end-to-end tests with Wallaby or similar:\n```elixir\ndefmodule EventasaurusAppWeb.ThemeFeatureTest do\n  use EventasaurusAppWeb.FeatureCase\n  \n  import Wallaby.Query\n  \n  setup do\n    # Create a test user and event\n    user = insert(:user)\n    event = insert(:event, organizer: user, theme: :minimal)\n    \n    %{user: user, event: event}\n  end\n  \n  feature \"organizer can change event theme\", %{user: user, event: event, session: session} do\n    # Log in\n    session\n    |> visit(\"/login\")\n    |> fill_in(text_field(\"Email\"), with: user.email)\n    |> fill_in(text_field(\"Password\"), with: \"password\")\n    |> click(button(\"Log in\"))\n    \n    # Navigate to event edit page\n    session\n    |> visit(\"/events/#{event.id}/edit\")\n    \n    # Select a theme\n    session\n    |> click(css(\".theme-option[data-theme='cosmic']\"))\n    \n    # Apply the theme\n    session\n    |> click(button(\"Apply Theme\"))\n    \n    # Verify success message\n    session\n    |> assert_has(css(\".alert-info\", text: \"Theme updated successfully\"))\n    \n    # Visit public page to verify theme\n    session\n    |> visit(\"/events/#{event.slug}\")\n    \n    # Verify theme is applied\n    session\n    |> assert_has(css(\".theme-cosmic\"))\n  end\n  \n  feature \"organizer can customize theme colors\", %{user: user, event: event, session: session} do\n    # Similar test for color customization\n  end\n  \n  feature \"theme is accessible\", %{event: event, session: session} do\n    # Visit public page\n    session\n    |> visit(\"/events/#{event.slug}\")\n    \n    # Test keyboard navigation\n    session\n    |> send_keys([:tab, :tab, :space])\n    \n    # Verify expected action occurred\n    session\n    |> assert_has(css(\".registration-form\"))\n  end\nend\n```\n\n4. Create developer documentation:\n```markdown\n# Eventasaurus Theming System - Developer Documentation\n\n## Overview\n\nThe Eventasaurus Theming System allows event organizers to customize the visual appearance of their event pages using predefined themes and custom styling options.\n\n## Architecture\n\n### Database Schema\n\nThemes are stored in the `events` table with two fields:\n- `theme`: An Ecto.Enum field with values [:minimal, :cosmic, :velocity, :retro, :celebration, :nature, :professional]\n- `theme_customizations`: A JSONB field storing customization options\n\n### CSS Architecture\n\nThe theming system uses a modular CSS architecture:\n- `base.css`: Contains shared theme foundation and CSS custom properties\n- Theme-specific CSS files: Override CSS custom properties for each theme\n- CSS custom properties are used for all themeable values\n\n### Context Modules\n\n- `EventasaurusApp.Themes`: Core theme utilities and validation\n- `EventasaurusApp.Events`: Event-related theme operations\n- `EventasaurusApp.Themes.AccessibilityValidator`: Ensures themes meet accessibility standards\n\n## Implementation Guide\n\n### Adding a New Theme\n\n1. Add the theme to the Event schema enum\n2. Create a new CSS file for the theme\n3. Add default customizations to the Themes context\n4. Add a thumbnail for the theme picker\n5. Update tests to include the new theme\n\n### Theme Customization Structure\n\n```json\n{\n  \"colors\": {\n    \"primary\": \"#hex_color\",\n    \"secondary\": \"#hex_color\",\n    \"accent\": \"#hex_color\",\n    \"background\": \"#hex_color\",\n    \"text\": \"#hex_color\"\n  },\n  \"typography\": {\n    \"font_family\": \"font_name\",\n    \"heading_weight\": \"weight_value\",\n    \"body_size\": \"size_value\"\n  },\n  \"layout\": {\n    \"border_radius\": \"radius_value\",\n    \"shadow_style\": \"style_name\"\n  },\n  \"mode\": \"light|dark\"\n}\n```\n\n### Performance Considerations\n\n- Theme CSS is loaded only when needed\n- Theme switching is optimized for performance\n- CSS custom properties allow for efficient theme changes\n\n### Accessibility Requirements\n\n- All themes must pass WCAG 2.1 AA standards\n- Color contrast is validated automatically\n- Keyboard navigation is supported across all themes\n\n## API Reference\n\n### Themes Context\n\n```elixir\n# Check if a theme is valid\nThemes.valid_theme?(theme) # Returns boolean\n\n# Merge customizations with defaults\nThemes.merge_customizations(theme, customizations) # Returns map\n\n# Validate customizations\nThemes.validate_customizations(customizations) # Returns {:ok, map} or {:error, reason}\n\n# Get CSS class for a theme\nThemes.get_theme_css_class(theme) # Returns string\n\n# Get default customizations\nThemes.get_default_customizations(theme) # Returns map\n```\n\n### Events Context\n\n```elixir\n# Update event theme\nEvents.update_event_theme(event, theme) # Returns {:ok, event} or {:error, reason}\n\n# Update theme customizations\nEvents.update_event_theme_customizations(event, customizations) # Returns {:ok, event} or {:error, reason}\n\n# Get complete theme data\nEvents.get_event_theme_data(event) # Returns map\n\n# Copy theme between events\nEvents.copy_event_theme(source_event_id, target_event_id) # Returns {:ok, event} or {:error, reason}\n```\n\n## Testing\n\n- Unit tests for theme validation and utilities\n- Integration tests for theme application\n- End-to-end tests for user workflows\n- Accessibility testing with automated tools\n- Performance testing for theme switching\n```\n\n5. Create user documentation:\n```markdown\n# Eventasaurus Theming System - User Guide\n\n## Introduction\n\nThe Eventasaurus Theming System allows you to customize the look and feel of your event pages. This guide will help you select and customize themes to match your brand or event style.\n\n## Selecting a Theme\n\n1. Navigate to your event's edit page\n2. In the \"Theme\" section, you'll see thumbnails for each available theme\n3. Click on a theme to preview it\n4. Click \"Apply Theme\" to save your selection\n\n## Available Themes\n\n- **Minimal**: Clean, modern design with lots of white space\n- **Cosmic**: Space/galaxy themed with dark backgrounds\n- **Velocity**: Tech/futuristic with gradients and geometric elements\n- **Retro**: Vintage/80s aesthetic with vibrant colors\n- **Celebration**: Party/confetti themed with festive colors\n- **Nature**: Organic patterns with earth tones\n- **Professional**: Corporate/business focused with sophisticated colors\n\n## Customizing Your Theme\n\n### Colors\n\n1. In the Theme Customization panel, select the \"Colors\" tab\n2. Use the color pickers to adjust:\n   - Primary Color: Used for buttons and important elements\n   - Secondary Color: Used for secondary elements\n   - Accent Color: Used for highlights and accents\n   - Background Color: The main page background\n   - Text Color: The main text color\n3. Try the color presets for quick, harmonious color schemes\n\n### Typography\n\n1. Select the \"Typography\" tab\n2. Choose a font family that matches your event's personality\n3. Adjust heading weight to make titles more or less bold\n4. Set body text size for comfortable reading\n\n### Layout\n\n1. Select the \"Layout\" tab\n2. Adjust border radius for rounded or sharp corners\n3. Choose a shadow style for depth and dimension\n4. Toggle between light and dark mode\n\n## Tips for Great-Looking Event Pages\n\n- Choose colors that match your event's branding\n- Ensure good contrast between text and background colors\n- Select fonts that reflect your event's personality\n- Preview your theme on both desktop and mobile devices\n- Consider both light and dark mode preferences\n\n## Copying Themes Between Events\n\n1. In the Theme section, find \"Copy Theme From Another Event\"\n2. Select the source event from the dropdown\n3. Click \"Copy Theme\" to apply the same theme and customizations\n\n## Troubleshooting\n\n- If colors appear incorrect, try refreshing the page\n- If theme changes aren't saving, check your internet connection\n- If text is hard to read, try adjusting the contrast between text and background colors\n\n## Accessibility\n\nAll themes are designed to meet accessibility standards. The system will warn you if your color choices might create readability issues.\n```",
      "testStrategy": "1. Verify all unit tests pass for the Themes context\n2. Test integration tests for theme application and customization\n3. Run end-to-end tests for complete user workflows\n4. Verify accessibility tests pass for all themes\n5. Test performance benchmarks for theme switching and loading\n6. Verify documentation is accurate and comprehensive\n7. Test with real users to validate usability\n8. Verify all test coverage meets project requirements\n9. Test edge cases like theme migration and compatibility\n10. Verify that the system gracefully handles errors and edge cases",
      "priority": "medium",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "status": "pending",
      "subtasks": []
    }
  ]
}